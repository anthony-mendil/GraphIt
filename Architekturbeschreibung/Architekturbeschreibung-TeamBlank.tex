\documentclass[enabledeprecatedfontcommands,fontsize=11pt,paper=a4,twoside]{scrartcl}


\newcommand{\grad}{\ensuremath{^{\circ}} }
\renewcommand{\strut}{\vrule width 0pt height5mm depth2mm}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[final]{pdfpages}
% obere Seitenränder gestalten können
\usepackage{fancyhdr}
\usepackage{moreverb}
% Graphiken als jpg, png etc. einbinden können
\usepackage{graphicx}
\usepackage{stmaryrd}
% Floats Objekte mit [H] festsetzen
\usepackage{float}
% setzt URL's schön mit \url{http://bla.laber.com/~mypage}
\usepackage{url}
% Externe PDF's einbinden können
\usepackage{pdflscape}
% Verweise innerhalb des Dokuments schick mit " ... auf Seite ... "
% automatisch versehen. Dazu \vref{labelname} benutzen
\usepackage[ngerman]{varioref}
\usepackage[ngerman]{babel}
\usepackage{ngerman}
% Bibliographie
\usepackage{bibgerm}
\usepackage{svg}
% Tabellen
\usepackage{tabularx}
\usepackage{supertabular}
\usepackage[colorlinks=true, pdfstartview=FitV, linkcolor=blue,
            citecolor=blue, urlcolor=blue, hyperfigures=true,
            pdftex=true]{hyperref}
\usepackage{bookmark}



\newcounter{one}
\newcounter{two}[one]
\newcounter{three}[two]

\newcommand{\tone}{0\theone}
\newcommand{\ttwo}{0\thetwo}
\newcommand{\tthree}{0\thetree}
\newcommand{\one}{\stepcounter{one}0\theone}
\newcommand{\two}{\stepcounter{two}0\thetwo}
\newcommand{\three}{\stepcounter{three}0\thethree}
\newcommand\s{\rule{0pt}{4ex}}        
\newcommand{\cb}[1]{{\textcolor{blue}{#1}}}

\usepackage{geometry}
\usepackage{hyperref}
\usepackage{pdfpages} 
\usepackage{colortbl}
%\usepackage{graphicx}   
%\usepackage[utf8x]{inputenc}
\usepackage{fmtcount}
\usepackage[ngerman]{babel}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage[T1]{fontenc}

\usepackage{rotating}

\pagestyle{fancy}
\fancyhf{}

%

%

%

%

\definecolor{dartmouthgreen}{rgb}{0.05, 0.5, 0.06}
\definecolor{color}{rgb}{0.67, 0.88, 0.69}
\definecolor{todo}{rgb}{1.0, 0.41, 0.71}
\definecolor{sort}{rgb}{0.45, 0.76, 0.98}
\definecolor{prob}{rgb}{0.74, 0.83, 0.9}
\definecolor{anw}{rgb}{0.94, 0.86, 0.51}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{setspace} 
\hypersetup{
	colorlinks = true,
	linkbordercolor = {white},
	linkcolor=dartmouthgreen,          % color of internal links (change box color with linkbordercolor)
	citecolor=red,        % color of links to bibliography
	filecolor=magenta,      % color of file links
	urlcolor=cyan 
}
\usepackage{geometry}
\geometry{
	a4paper,
	left=20mm,
	right=20mm,
	top=2cm,
	bottom=4cm,
	footskip=4cm
}


\addtolength{\headwidth}{20mm}
\addtolength{\headheight}{2\baselineskip}
\addtolength{\headheight}{0.61pt}


\renewcommand{\headrulewidth}{0pt}
\renewcommand{\headrule}{\vbox to 0pt{\rule{\headwidth}{0.2pt}}}
\setlength{\headsep}{30pt}


\hyphenation{Arbeits-paket}

% Damit Latex nicht zu lange Zeilen produziert:
%\sloppy
%Uneinheitlicher unterer Seitenrand:
%\raggedbottom

% Kein Erstzeileneinzug beim Absatzanfang
% Sieht aber nur gut aus, wenn man zwischen Absätzen viel Platz einbaut
\setlength{\parindent}{0ex}

% Abstand zwischen zwei Absätzen
%\setlength{\parskip}{1ex}

% Seitenränder für Korrekturen verändern
%\addtolength{\evensidemargin}{-1cm}
%\addtolength{\oddsidemargin}{1cm}

%\bibliographystyle{gerapali}

% Lustige Header auf den Seiten
  \pagestyle{fancy}
  \setlength{\headheight}{70.55003pt}
  \fancyhead{}
  \fancyhead[LO,RE]{Software--Projekt 2\\ WiSe 2018/2019
  \\Architekturbeschreibung}
  \fancyhead[LE,RO]{Seite \thepage\\\slshape \leftmark\\\slshape \rightmark}

%
% Und jetzt geht das Dokument los....
%

\begin{document}

% Lustige Header nur auf dieser Seite
  \thispagestyle{fancy}
  \fancyhead[LO,RE]{ }
  \fancyhead[LE,RO]{Universität Bremen\\FB 3 -- Informatik\\
  Prof. Dr. Rainer Koschke \\Tutor/In: Marcel Steinbeck}
  \fancyfoot[C]{}

% Start Titelseite
  \vspace{3cm}

  \begin{minipage}[H]{\textwidth}
  \begin{center}
  \bf
  \Large
  Software--Projekt 2 WiSe 2018/2019\\
  \smallskip
  \small
  VAK 03-BA-901.02\\
  \vspace{3cm}
  \end{center}
  \end{minipage}
  \begin{minipage}[H]{\textwidth}
  \begin{center}
  \vspace{1cm}
  \bf
  \Large Architekturbeschreibung \\ 
  \vspace{1cm}
  \Huge\textbf{GraphIt}\normalsize
  \vfill
  \end{center}
  \end{minipage}
  \vfill
  \begin{minipage}[H]{\textwidth}
  \begin{center}
  \sf
  \begin{tabular}{lr}
  Anthony Mendil & antmen@tzi.de \\
  Bastian Rexhäuser & brexhaeu@tzi.de\\
  Clement Phung & clement1@tzi.de \\
  Jacky Philipp Mach & machja@tzi.de \\
  Jonah Jaeger & jjaeger@tzi.de \\
  Nina Unterberg & nin\_unt@tzi.de \\
  \end{tabular}
  \\ ~
  \vspace{2cm}
  \\
  \it Abgabe: 23. Dezember 2018 --- Version 4.0\\ ~
  \end{center}
  \end{minipage}

% Ende Titelseite
% Start Leerseite
\thispagestyle{empty}
\cleardoublepage
% Ende Leerseite
\newpage

  \thispagestyle{fancy}
  \fancyhead{}
  \fancyhead[LO,RE]{Software--Projekt \\  2018/2019
  \\Architekturbeschreibung}
  \fancyhead[LE,RO]{Seite \thepage\\\slshape \leftmark\\~}
  \fancyfoot{}
  \renewcommand{\headrulewidth}{0.4pt}
  \tableofcontents

\newpage

  \fancyhead[LE,RO]{Seite \thepage\\\slshape \leftmark\\\slshape \rightmark}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Start Leerseite
\thispagestyle{empty}
\cleardoublepage
% Ende Leerseite
\fancyhead[LE,RO]{Seite \thepage\\\slshape Version und Änderungsgeschichte\\~}

\section*{Version und Änderungsgeschichte}
\emph{Autoren: Bastian Rexhäuser, Jonah Jaeger}\\ \\
Im folgenden ist eine Tabelle zu finden, die Aufschluss darüber ermöglicht, mit welchen Zwischenschritten das vorliegende Dokument in seinen jetzigen Zustand gekommen ist. Dazu sind neben dem Datum eindeutige Versionsnummern angegeben. Durch die Datum-Angabe zu den einzelnen Versionen kann darüber hinaus festgestellt werden wie viel Zeit die jeweils in der Änderungsspalte beschriebenen Fortschritte benötigt haben. Dabei ist zu beachten, dass mit unter zeitgleich an mehreren Abschnitten des Dokumentes gearbeitet wurde, sodass die errechneten Angaben zur Bearbeitungsdauer vom tatsächlichen Zeitaufwand abweichen können. Am Ende der Liste steht die aktuelle Versionsnummer, die auch auf dem Deckblatt zu finden ist.  \\

\begin{tabular}{p{1,2cm}cp{12cm}}
Version & Datum & Änderungen \\
\hline
0.0 & 28.10.2018 & Aufsetzen eines LaTeX-Dokuments und Festlegung grundlegender Layout-Entscheidungen \\
0.1 & 30.10.2018 & Einfügen einer vorläufigen Gliederung \\
0.2 & 02.11.2018 & Anpassung des Layouts \\
1.0 & 03.11.2018 & Erarbeitung der Einleitung \\
1.1 & 15.11.2018 & Vorläufige Version der Einflussfaktoren \\
1.2 & 27.11.2018 & Einflussfaktoren an geänderte Anforderungen angepasst \\
1.3 & 30.11.2018 & Vorerst finale Version der Einflussfaktoren und Problemkarten  \\
1.4 & 03.12.2018 & Erste Version der Konzeptionellen Sicht\\
1.5 & 04.12.2018 & Beschreibung der Konzeptionellen Sicht hinzugefügt\\
1.6 & 05.12.2018 & Einflussfaktoren und Problemkarten noch etwas verändert \\
1.7 & 06.12.2018 & Erste Version der Anwendungsfälle \\
1.8 & 07.12.2018 & Erste Version der Datensicht \\
1.9 & 09.12.2018 & Beschreibung der Datensicht \\
2.0 & 09.12.2018 & Komplett neu aufgesetztes Dokument \\
2.1 & 11.12.2018 & Überarbeitete Datensicht und für diese benötigte Problemkarten hinzugefügt\\
2.2 & 12.12.2018 & Überarbeitete Version der Konzeptionellen Sicht \\
2.3 & 12.12.2018 & Erste Version der Modulsicht \\
2.4 & 13.12.2018 & Erste Version der kompletten Klassendiagramme \\
2.5 & 14.12.2018 & Erste Version der Evolution \\
2.6 & 14.12.2018 & Erste Version der Ausführungssicht \\
2.7 & 14.12.2018 & Überarbeitung, Formalisierung und Strukturierung der Anwendungsfälle \\
2.8 & 16.12.2018 & Sequenzdiagramme zu den Anwendungsfällen \\
2.9 & 16.12.2018 & Klassendiagramme in Modulsicht-Abschnitte eingegliedert \\
3.0 & 17.12.2018 & Geprüfte Version der Einleitung, Datensicht, Konzeptionellen Sicht und Evolution\\
3.1 & 19.12.2018 & Überarbeitete und geprüfte Version der Ausführungssicht und der globalen Analyse\\
3.2 & 19.12.2018 & Final geprüfte Version der Ausführungssicht \\
3.3 & 20.12.2018 & Geprüfte Version der Modulsicht \\
3.4 & 21.12.2018 & Vorläufig generell überprüfte Version des Dokuments \\
\textbf{4.0} & \textbf{22.12.2018} & \textbf{Endgültige Version der Architekturbeschreibung} \\


\end{tabular}
\\ \\ \\ \newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Start Leerseite
\thispagestyle{empty}
\cleardoublepage
% Ende Leerseite

\fancyhead[LE,RO]{Seite \thepage\\\slshape \leftmark\\\slshape \rightmark}

\newpage
\section{Einführung}
\label{sec:intro}
\emph{Autoren: Bastian Rexhäuser}
\subsection{Zweck}
Die vorliegende Architekturbeschreibung ist ein Dokument mit hoher Bedeutung für die Implementierung, das Testen und die Wartung der Software. Durch die Architekturbeschreibung wird eine weitreichende Übersicht über die Softwarestruktur, wichtige Einflussfaktoren und Probleme, die bei der Softwareimplementierung auftreten können, gegeben. Die Architekturbeschreibung zeigt außerdem Strategien zur Lösung dieser Probleme auf und benennt die Komponenten und Module, in die wir die Software zu gliedern planen, sowie deren Bestandteile und Funktion. Damit stellt sie dem Leser eine Grundlage zur Verfügung, um die Vollständigkeit unserer Anwendung bereits vor der Implementierung zu prüfen, die Struktur nachzuvollziehen und bestimmte Entscheidungen hinsichtlich des geplanten Softwareaufbaus verstehen zu können. Zu den Lesern des Dokumentes gehören der Auftraggeber sowie die Autoren, die zur Implementierung, zum Testen und zum Schreiben des Benutzerhandbuchs auf dieses Dokument zurückgreifen werden. Durch die oben angesprochene Gliederung der Software und das Benennen der vorgesehenen Komponenten, Schnittstellen und Module sowie derer Bestandteile als solche und deren Aufgabe im Kontext des gesamten Systems erhalten Tester einen Ansatzpunkt, um ein strukturiertes Testprotokoll anfertigen zu können. Besonders hilfreich wird dieses Dokument für eine gut geplante Umsetzung der Integrationstests sein. Durch die Erstellung dieses Dokumentes kann außerdem die Wahrscheinlichkeit für Fehlentwicklungen bei der Implementierung reduziert und somit einen großen Zeitverlust vorgebeugt werden, was wiederum dazu führt, dass die sich an die Implementierung anschließenden Schritte wie beispielsweise das eben erwähnte Testen früher begonnen werden können. Schlussendlich hat es damit den Zweck den Abgabetermin einhalten zu können. Letztere Behauptung kann damit gestützt werden,  dass der Auftraggeber Fehlentwicklungen frühzeitig erkennen und diese vermitteln kann. Die verschiedenen Sichten geben verschiedene Blickwinkel auf das System und illustrieren auf diese Weise das Zusammenspiel verschiedener Komponenten besser als eine einzelne Sicht dazu in der Lage wäre. Auch dient dies der Verständlichkeit unseres Systems und hilft uns bei der Implementierung. Neben der Hilfe für die Implementierung, die aus der Aufgliederung des Gesamtsystems in dessen Bestandteile und der Darstellung verschiedener Sichten resultiert, ist dieses Vorgehen auch zur Erhöhung der Wartbarkeit unserer Software nützlich. Denn es ermöglicht eine zielgerichtete Suche nach den Bestandteilen, die von Änderungen an den Anforderungen betroffen sind. Dabei spielt die Evolution eine besonders große Rolle. Wie dargestellt ist das vorliegende Dokument auch über die (Erst-)Implementierungsphase der Software hinaus von Bedeutung.
\newpage
\subsection{Status}
Erstentwurf eines abgeschlossenen Dokumentes. \\
Wir betrachten das vorliegende Exemplar als abgeschlossen. Dies bedeutet nicht, dass es in der vorliegenden Form dauerhaft Anspruch auf Fehlerfreiheit erhebt. Vielmehr ist mit abgeschlossen gemeint, dass alle für eine Architekturbeschreibung relevanten Themen zumindest thematisiert worden. Es ist also durchaus möglich, dass Lücken innerhalb einzelner Abschnitte enthalten sind. Diese können beispielsweise bei dem folgenden Kapitel \hyperref[sec:daa]{Definitionen, Akronyme und Abkürzungen} auftreten, wenn der Kunde einige Begrifflichkeiten nicht versteht und deren Bedeutung uns als selbsterklärend erscheint. Fehler können insofern enthalten sein, als dass hier nur der aktuelle Stand der Technik, der Anforderungen und sonstiger Rahmenbedingungen dargestellt werden kann. Damit kann dieser Entwurf bei Aufkommen neuer Technologien, sich ändernden Anforderungen oder vergleichbarer Prozesse an Aktualität und Richtigkeit, beispielsweise im Bezug auf die besten Ansätze zur Lösung bestimmter Probleme, verlieren.

\newpage
\subsection{Definitionen, Akronyme und Abkürzungen}
\label{sec:daa}
- \textbf{Maven} ist der Name eines Build-Management-Tools, welches auf Java basiert und zur Erstellung von Anwendungen, die in dieser Programmiersprache geschrieben wurden, genutzt werden kann. \\ \\
- \textbf{Java 8} ist die Version der Programmiersprache Java, in der die Implementierung des vom Kunden geforderten Systems erfolgen wird. Java selbst ist eine objektorientierte Programmiersprache. \\ \\
- \textbf{Frameworks} sind Programmiergerüste, die verwendet werden können, um Implementierungsarbeit zu sparen und die Verständlichkeit des Programmcodes durch Verwendung bekannter Bausteine zu erhöhen. \\ \\
- \textbf{GUI} Graphical User Interface (=Benutzeroberfläche) - hierbei handelt es sich um die Darstellung der für den Nutzer sichtbaren Teile unserer Software. Es dreht sich also bei der GUI um die visuellen Bestandteile des Programms, die es einem Verwender ermöglicht, die Programmfunktionen (intuitiv) nutzen zu können. Vereinfacht ausgedrückt kann in diesem Fall der Nutzer über die GUI einen Graphen erstellen und editieren sowie eine Auswertung des Graph-Erstellungsprozesses und des dabei entstandenen Diagramms durchführen. \\ \\
- \textbf{H2} ist ein mit Java kompatibles relationales Datenbanksystem. Dieses kann auch für Desktop-Anwendungen genutzt werden, da es die Existenz eines (Web-)Servers nicht voraussetzt.\\ \\
- \textbf{GXL} (Graph eXchange Language) ist ein Dateiformat, das dem Graphenaustausch zwischen Programmen dient. \\ \\
- \textbf{SVG} (=Scalable Vector Graphics) Hierbei handelt es sich um eine Spezifikation zur Darstellung von Vektorgrafiken im Web. Diese Spezifikation basiert auf XML.  \\ \\
- \textbf{XML} (=eXtensible Markup Language) ist ein Dateiformat, das von Menschen und Computern geschrieben und gelesen werden kann. Es dient dem Austausch von Daten, die in hierarchisch strukturierter Form organisiert sind, zwischen verschiedenen Computern. \\ \\
- \textbf{PDF} (Portable Document Format) ist ein plattformunabhängiges Dateiformat, das die Erstellung eines Dokuments ermöglicht, das vom ursprünglichen Anwendungsprogramm losgelöst geöffnet und gelesen werden kann. Das Format gibt dabei den Inhalt des Ursprungsprogramms originalgetreu wieder (sowohl Inhalt als auch Darstellung). \\ \\
- \textbf{CSV} (=Comma-separated values) ist ein Format zum Speichern und Laden einfach strukturierter Daten.\\ \\
- \textbf{SQL} (Structured Query Language) ist eine Sprache zur Interaktion mit Datenbanken. \\ \\
- \textbf{.oof} ist ein von uns entwickeltes Dateiformat, das Nutzerinteraktionen und Graphinformationen zusammenführt. \\ \\
- \textbf{io (input/output)} beschreibt bei uns die Eingabe und Ausgabe von Dateien. Bei uns sind das der Import und Export von GXL- und OOF-Dateien sowie das Drucken und Exportieren von PDF-Dateien. \\ \\
- \textbf{Build-System} ist ein System, welches das Projekt vom Quellcode in einen ausführbaren Zustand versetzt. \\ \\
- \textbf{Quellcode} ist eine Menge von Zeichen und Zeichenketten, die von Menschen geschrieben, von Computern interpretiert und von einem Build-System in ein Programm umgewandelt werden kann.  \\ \\
- \textbf{Graph} ist ein Wirkungsdiagramm und somit eine visuelle Darstellung für den Syndromansatz.  \\ \\
- \textbf{\hypertarget{Syndromansatz}{Syndromansatz}} ist ein vom \glqq Wissenschaftlichen Beirat der Bundesregierung Globale Umweltveränderung \grqq{} (WBGU) entwickeltes Modell zur Identifikation von Fehlentwicklungen besonders in den Bereichen Biologie, Gesellschaft und Wirtschaft, um Gegenmaßnahmen planen und durchführen zu können. Es geht hierbei grob gesagt um ein Modell zur Erkennung von \glqq Krankheitsbildern\grqq. \\ \\
- \textbf{Syndrom} (=Krankheitsbild) ist ein aus Symptomen (Knoten) und deren Wechselwirkungen (dargestellt über Relationen/Kanten) bestehender Graph in seiner Gesamtheit. \\ \\
- \textbf{\hypertarget{Sphaere}{Sphäre}} ist ein zusammenhängender, nicht-überlappender im Diagramm dargestellter (Themen-)Bereich, zu dem Symptome zugeordnet wird. Sie werden durch Linien voneinander abgetrennt, haben eine wählbare Hintergrundfarbe und können mittels eines Textes beschrieben werden. \\ \\
- \textbf{\hypertarget{Symptom}{Symptom}} ist ein Knoten im Graphen.  \\ \\
- \textbf{Relationen} sind gerichtete Kanten von einem Knoten zu einem anderen Knoten im Graphen und dienen der Repräsentation von Wirkungszusammenhängen zwischen Symptomen, wobei zwischen drei Relationstypen unterschieden werden: verstärkend, abschwächend und unbekannt. Die Pfeilspitzen der Relationen sind vom Typ der Relation abhängig und werden ebenso vom Kunden vorgegeben wie mögliche Dicken und Linienarten der Kanten. Die Farben der Kanten können vom Nutzer gewählt werden. Überlappungen von Kantenenden verschiedener Relationstypen, die am selben Knoten eingehen, sind nicht erlaubt. \\ \\
- \textbf{Ankerpunkte}  sind Stellen an einem Knoten, mit denen der Nutzer den Beginn oder das Ziel einer Kante mit gleichen Relationstypen definieren kann. \\ \\
- \textbf{Pfeilkette} Hiervon ist die Rede, wenn mindestens drei Kanten in dieselbe Richtung zeigen, ohne dass es zu einer Verzweigung bei den inneren Knoten der Kette kommt. Von einem inneren Knoten einer Kette ist ist die Rede, wenn er nicht der Start- und nicht der Endknoten der Kette ist. \\ \\
-\textbf{Verzweigung} Ein Knoten, zu dem zwei oder mehr Kanten hin- bzw. von ihm wegführen, wobei auch beides möglich ist. \\ \\
-\textbf{\hypertarget{Kreislauf}{Kreislauf (Zyklus)}} Eine Kette von Kanten, die geschlossen ist und deren Kanten alle in die gleiche Richtung zeigen. Dabei ist jeder Knoten im Zyklus von jeden anderen Knoten in dem entsprechenden Zyklus aus durch die Kette erreichbar. Eine direkte Rückkopplung ist der kleinste Kreislauf. \\ \\
- \textbf{Komponente} Eine ziemlich abstrakte Gliederungseinheit einer Software. Die Komponente ist in der Lage mit anderen Komponenten zu kommunizieren und auf diese Weise vom Benutzer geforderte Aufgaben zu lösen - sofern die Komponenten die gewünschte Funktionalität durch Implementierung seitens der Entwickler unterstützen. \\ \\
- \textbf{Modul} Hierbei handelt es sich um einen Programmteil, der eine eigenständige - im Sinne von abgeschlossene - funktionale Einheit darstellt. Ein Modul enthält in der Regel Strukturen, die die Umrechnung von Daten ermöglichen. Somit ist es verständlich, dass ein Modul - sofern es aufgerufen (anders ausgedrückt: beansprucht) wird, Daten an das System zurückgeben kann. Die Rückgabe ist dann, grob gesagt, als das Umrechnungsergebnis der Daten zu verstehen, die an das Modul übergeben wurden. \\ \\
- \textbf{Programmierschnittstelle} (präziser ausgedrückt Schnittstelle zur Anwendungsprogrammierung; engl. application programming interface - kurz API) ist ein Bestandteil des Programms, dessen Aufgabe es ist, anderen Programmen die Möglichkeit zur Anbindung an das eigene System zu geben.\\ \\
- \textbf{(Nutzer-)Rolle} Wann immer im Dokument von Rollen oder Nutzerrollen die Rede sein wird, ist damit nicht ein Rechtemanagement, sondern vielmehr die Bereitstellung verschiedener Modi gemeint. Jeder Nutzer kann dabei jede Rolle einnehmen und somit das System in jedem Modus verwenden. \\ \\
- \textbf{\hypertarget{``Vorlage bearbeiten''-Modus}{\glqq Vorlage bearbeiten\grqq -Modus}} entspricht der Rolle eines Erstellers. Dieser Modus stellt Funktionen bereit, um ein Diagramm als Vorlage zu erstellen und um bestimmte Bearbeitungsregeln für diese Vorlage festzulegen. Zur Erstellung der Vorlage kann in diesem Modus die Anzahl, Farbgebung und Beschriftung/Benennung der Sphären und Knoten eingestellt und zudem festgelegt werden, welche Kanten verwendet werden können. Optional kann darüber hinaus auch die Größe und Position aller Graph-Elemente sowie der bei der Beschriftung verwendete Zeichensatz ausgewählt werden. Der Verwender dieses Modus kann zudem für jedes Element in der Vorlage einzeln festlegen, ob es einem Verwender im \glqq Diagramm bearbeiten\grqq-Modus gestattet ist, dieses Element zu bearbeiten. Dieser Modus wird üblicherweise von Lehrern zur Erstellung einer Vorlage für ein Diagramm verwendet. \\ \\
- \textbf{\hypertarget{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten\grqq-Modus}} erfüllt die Ansprüche einer Betrachter-Rolle an das System. In diesem Modus kann ein Benutzer ein Diagramm auf Basis einer Vorlage erstellen und dazu die Vorlage im Rahmen der Regeln aus der gegebenen Vorlage verändern. Ist dieser Modus aktiv, so wird ein Protokoll angelegt, welche Interaktionen des Nutzers in diesem Modus aufzeichnet. Zu den aufgezeichneten Daten gehört ein Zeitstempel sowie die Aktion (z.B. Erstellung, Bearbeitung oder Verschiebung von Sphären, Knoten und Kanten). Dieser Modus ist besonders für Kinder ab 10 Jahren geeignet, die durch ihn komplexe Zusammenhänge verstehen sollen. Um das Verständnis leichter zu machen, sollen auch in diesem Modus bereits \hyperlink{Bedeutung eines Knoten}{gewisse Analyse-Funktionen hinsichtlich der Bedeutung einzelner Knoten} verfügbar sein. Die Analyse-Funktion bezüglich des Protokolls der Nutzerinteraktionen ist nicht verfügbar. Ferner ist alles, was in diesem Modus möglich ist, auch im \hyperlink{``Vorlage bearbeiten''-Modus}{\glqq Vorlage bearbeiten\grqq -Modus} möglich.\\ \\
- \textbf{\hypertarget{``Analyse''-Modus}{\glqq Analyse\grqq -Modus}} Dieser Modus ist mit einer Auswerter-Rolle vergleichbar. Er stellt Funktionen bereit, um einen erstellten Graphen analysieren zu können (z.B. hinsichtlich der \hyperlink{Bedeutung eines Knoten}{Bedeutung einzelner Knoten}). Diese Analyse beinhaltet darüber hinaus zum einen die Bereitstellung von Möglichkeiten, mit denen man \hyperlink{Metriken}{Metriken/Graphmaße} berechnen kann und zum anderen ein Protokoll, das Aufschluss über die Nutzerinteraktionen (wie zum Beispiel die Reihenfolge, in der Knoten erstellt wurden) gewährt. Dieser Modus wird voraussichtlich von Wissenschaftlern in der Didaktik und eventuell auch von Lehrern verwendet werden. \\ \\
- \textbf{\hypertarget{Bedeutung eines Knoten}{Bedeutung eines Knoten}} Die Relevanz eines Knoten ist von der Vernetztheit des Knotens abhängig. Dabei sind mögliche Maßstäbe für Wichtigkeit und Grad der Vernetztheit folgende: Sei K ein Knoten... \\
\begin{itemize}
\item Anzahl der benachbarten Knoten von K (nur Vorgänger, nur Nachfolger, alle Nachbarn)
\item Anzahl der ein- und/oder ausgehenden Kanten (mit und ohne Abhängigkeit des Relationstyps) von K
\item Pfeilketten, konvergente und divergente Verzweigungen, Zyklen beliebiger Länge im Graphen
\end{itemize}
- \textbf{\hypertarget{Metriken}{Metriken/Graphmaße}} vorgegebene Messgrößen des Syndromansatzes. Man unterscheidet zwischen
\begin{itemize}
\item \hypertarget{Umfang}{Umfang}: Anzahl wertbarer Symptome + Anzahl wertbarer Relationen (nach Sommer, 2005, S. 151)
\item \hypertarget{Vernetzungsindex}{Vernetzungsindex}: 2 * Anzahl wertbarer Realtionen / Anzahl wertbarer Symptome (nach Ossimitz, 2000, S. 210)
\item Summer aller Pfeilketten, Verzweigungen und Kreisläufe / Anzahl wertbarer Symptome (nach Kunz \& Bollmann-Zuberbühler, 2008, S. 106)
\end{itemize}

\newpage
\subsection{Referenzen} 
Die folgende Liste enthält Verweise zu Lösungen, die in diesem Dokument erwähnt werden. Bei den Lösungen handelt es sich zumeist um Frameworks. Um Recherchen zu diesen schnellstmöglich umsetzen zu können, sind neben den Namen auch Links zu den Webseiten der Lösungen angegeben. Der Vollständigkeit halber steht neben den Links das Datum des jeweils letzten Aufrufs. Außerdem finden sich in dieser Liste auch Literaturhinweise zu Werken, die aus der Domäne des Kunden stammen und auf die in diesem Dokument Bezug genommen wird. \\ \\
Die Liste der erwähnten Tools/Frameworks ist auf der folgenden Seite dargestellt. \\
\newpage
\begin{tabular}{p{3,5cm}p{9cm}p{3,5cm}}
	Name der Lösung & Link & zuletzt aufgerufen am \\ \hline \\
	Apache Maven & \url{http://maven.apache.org/} & 17.12.2018 \\ \\
	Apache OpenJPA & \url{http://openjpa.apache.org/} & 17.12.2018 \\ \\
	Command-Entwurfmuster & \url{https://de.wikipedia.org/wiki/Kommando_(Entwurfsmuster)} & 17.12.2018 \\ \\
	EclipseLink & \url{https://www.eclipse.org/eclipselink/} & 17.12.2018 \\ \\
	Freeheb Vectorgraphics & \url{http://java.freehep.org/vectorgraphics/} & 17.12.2018 \\ \\
	GSON & \url{https://en.wikipedia.org/wiki/Gson} &  17.12.2018 \\ \\
	GXL-Tool (von SourceForge gehostet) & \url{https://sourceforge.net/projects/gxl/} & 17.12.2018 \\ \\
	H2 & \url{http://www.h2database.com/html/main.html} & 17.12.2018 \\ \\
	Hibernate & \url{http://hibernate.org/orm/} & 17.12.2018 \\ \\
	iText & \url{https://itextpdf.com/} & 17.12.2018 \\ \\
	Jackson & \url{https://en.wikipedia.org/wiki/Jackson_(API)} & 17.12.2018 \\ \\
	java.awt.Graphics2D & \url{https://docs.oracle.com/javase/7/docs/api/java/awt/Graphics2D.htm} & 17.12.2018 \\ \\
	JGraphT & \url{https://jgrapht.org/} & 17.12.2018 \\ \\
	JSONP & \url{https://www.w3schools.com/js/js_json_jsonp.asp} & 17.12.2018 \\ \\
	Model-View-Controller & \url{https://de.wikipedia.org/wiki/Model_View_Controller} & 17.12.2018 \\ \\
	java.awt.Graphics2D & \url{https://docs.oracle.com/javase/7/docs/api/java/awt/Graphics2D.html} & 17.12.2018 \\ \\
	JUNG - Java Universal Network/Graph Framewor & \url{http://jung.sourceforge.net/} & 17.12.2018 \\ \\
	Scene-Builder & \url{https://www.oracle.com/technetwork/java/javase/downloads/javafxscenebuilder-info-2157684.html} & 17.12.2018 \\ \\
\end{tabular}
\\ \\ \\
Im folgenden ist die im Dokument erwähnte Fachliteratur gelistet: \\ \\
\begin{tabular}{p{11cm}p{5cm}}
	Werk & wird hier erwähnt \\ \hline \\
	Danny Holten (2006). Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data. In: IEEE Transactions on Visualization and Computer Graphics, 12(5), September 2006, 741-748. ISSN 1077-2626. & \hyperlink{cc}{Überlappung von Knotenenden des selben Relationstyps} \\ \\ 
	Sommer, C. (2005). Untersuchung der Systemkompetenz von Grundschülern im Bereich Biologie.& \hyperlink{Umfang}{Umfang} \\ \\
	Ossimitz, G. (2000). Entwicklung systemischen Denkens. Theoretische Konzepte und empirische Untersuchungen. München: Profil. & \hyperlink{Vernetzungsindex}{Vernetzungsindex} \\ \\
	Kunz, P. \& Bollmann-Zuberbühler, B. (2008): Ist systemisches Denken lehr- und lernbar? In U. Frischknecht-Tobler, U. Nagel \& H. Seybold (Hrsg.), Systemdenken. Wie Kinder und Jugendliche komplexe Systeme verstehen lernen. (S. 33-52). Zürich: Pestalozzianum. & \hyperlink{Strukturindex}{Strukturindex} \\ \\
\end{tabular}




\newpage
\subsection{Übersicht über das Dokument}
Zu Beginn dieses Dokuments befindet sich eine Einführung (\hyperref[sec:intro]{Kapitel 1}), in welcher auch dieser Abschnitt zu verordnen ist. Hier erläutern wir kurz den Zweck des Dokuments, nennen mögliche Leser/innen, erklären einige wichtige Begriffe und geben Referenzen an.  \\
Im Anschluss hieran erfolgt die globale Analyse (\hyperref[sec:globale_analyse]{Kapitel 2}), in welcher zuerst Einflussfaktoren in Form von Faktortabellen aufgelistet und anschließend mögliche struktur- und implementierungsbezogene Probleme benannt und die dazugehörigen, von uns vorgeschlagenen Strategien beschrieben werden. Im Zuge dessen erfolgt jeweils auch eine begründete Entscheidung für eine Strategie oder für eine Kombination verschiedener Strategien. In diesem Teil des Dokuments setzen wir uns mit den Möglichkeiten auseinander, wie wir unser System anforderungsgemäß und ansprechend gestalten können. \\
Danach beschäftigen wir uns mit den Sichten nach Hofmeister - beginnend mit der konzeptionellen Sicht, mit der sich anschließenden Modulsicht und abschließend mit der Ausführungssicht. Zusätzlich zu diesen Sichten werden wir eine Datensicht beschreiben. Diese und die Sichten nach Hofmeister finden sich in Kapitel 3 bis 6. Diese gewähren weitreichende und vielseitige Blicke auf unser System. \\
In \hyperref[sec:anwendungsfaelle]{Kapitel 7} illustrieren wir das Zusammenspiel der in unserem System vorgesehenen Module anhand von fünf Anwendungsfällen, wobei wir Sequenzdiagramme zur Hilfe nehmen. \\
\hyperref[sec:evolution]{Kapitel 8} besteht aus einer Evolution, die einen Blick auf die Zukunft gewährt. Hier wird für ausgewählte Anforderungen beschrieben, wie sich Veränderungen/Erweiterungen derselben auf die Architektur auswirken würden. Des Weiteren werden wir beschreiben, welche Anforderungen, deren Umsetzung in der jetzigen Architektur nicht vorgesehen ist, hinzukommen könnten und welche Anpassungen der Architektur für deren Realisierung notwendig wären.


\newpage
\section{Globale Analyse}
\label{sec:globale_analyse}

\emph{Autoren: Bastian Rexhäuser, Jonah Jaeger, Nina Unterberg}\\ \\
Dieses Kapitel beginnt mit einer Auflistung von Einflussfaktoren, der sich eine Reihe von Problemkarten mit Strategien zur Beseitigung dieser Probleme anschließt.
\subsection{Einflussfaktoren}
\label{sec:einflussfaktoren}

Zur Beurteilung der Flexibilität und der Veränderlichkeit der einzelnen Einflussfaktoren habe wir eine Skalierung mit fünf verschiedenen Abstufungen gewählt, die der folgenden Tabelle entnommen werden kann. Mit Flexibilität ist dabei das Ausmaß, zu dem wir den jeweiligen Faktor zum jetzigen Zeitpunkt beeinflussen können, gemeint. Veränderlichkeit hingegen beschreibt die prognostizierte Wahrscheinlichkeit einer Änderung des jeweiligen Einflussfaktors als solchen. Es geht also bei Veränderlichkeit nicht darum, dass zu einem späteren Zeitpunkt konkrete Vorgaben zur technischen Umsetzung einer Anforderung gemacht werden könnten. \\

\begin{tabular}{p{2cm}p{8cm}}
	Symbol & Ausmaß der Flexibilität / Veränderlichkeit \\ \hline \\
	++ & sehr hoch \\ 
	+ & eher hoch \\ 
	o & neutral / weder hoch noch gering \\ 
	- & eher gering \\ 
	-- & sehr gering \\ 
\end{tabular}\\ \\ \\




\newpage
\def\arraystretch{1.5}
\subsubsection{Produktfaktoren}
\setcounter{one}{1}
\subsubsection*{\hypertarget{a}{P\tone}: System-Architektur-Eigenschaften} 
\begin{tabular}{|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} { \parbox{16cm}{\textbf{\hypertarget{b}{P\tone.\two}: Java 8 oder höher als Implementierungssprache} }} \\  
	\hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Für die Implementierung der Software ist die Verwendung von Java 8 oder einer aktuelleren Version der genannten Programmiersprache vorgeschrieben.}}\s\\ [1ex]
	\hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\ 
	(o) Wir haben eine gewisse Auswahlmöglichkeit bei der Java-Version, da nur eine Mindestaktualität der Java-Version gefordert ist. Uns ist sogar die 			Wahlmöglichkeit zwischen open-JDK und oracle-JDK überlassen. &
	(--) Es ist keine Änderung der geforderte Programmiersprache abzusehen und vorerst ist auch nicht mit
	der Vorgabe einer aktuelleren Mindest-Java-Version
	zu rechnen.
	\\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\ 
	\multicolumn{2}{|l|} {\parbox{16cm}{Alle Komponenten, die wir entwickeln, müssen auf Java 8 lauffähig sein und die von uns verwendeten Frameworks und Tools müssen mit dieser Version kompatibel sein.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{c}{P\tone.\two}: Verwendung von Maven als Build-System}} }\\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Bei der Erstellung der Software ist ein Build-System einzusetzen. Für das Projekt ist uns die Nutzung von Maven als Build-System vorgegeben.} }\s\\ [1ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Es besteht lediglich die Wahl zwischen den verfügbaren Maven-Versionen. Es ist uns zwar komplett überlassen, welche Version wir nehmen, jedoch haben wir keinen Einfluss auf das Build-System selbst. Somit kommen wir auf eine mittlere Flexibilität. &
	(-) Es ist nicht wahrscheinlich, dass zu einem anderen Build-System gewechselt werden soll oder eine Mindestanforderung hinsichtlich der Maven-Version an uns gestellt wird. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Die Architektur unserer Software ist initial als Maven-Projekt zu entwerfen. Dies führt zu einer standardisierten Projekt-Grundstruktur. Diese beinhaltet unter anderem eine .pom-Datei, in der die Maven-Dependencies eingebunden und einige Einstellungen festgelegt werden müssen.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{d}{P\tone.\two}: Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}} }\s \\ [1ex] \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Im Projekt ist  die Verwendung einer leichtgewichtigen (embedded) Datenbank vorgeschrieben. Diese ist zur Realisierung der Persistenz zu verwenden. Konkret sollen in der Datenbank die Nutzerinteraktionen/das Protokoll gespeichert werden.} }\rule{0pt}{6ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Wir haben die Wahl zwischen verschiedenen relationalen Datenbanken (zum Beispiel H2, SQLite  oder Apache Derby). Ferner ist uns freigestellt ein Persistenz-Framework (JPA) zu verwenden -  wobei unter diesen Umständen die deklarative Benutzung von SQL-ähnlichen Abfragen für uns vorgeschrieben ist. &
	(o) Die Regelungen hinsichtlich der Verwendung einer Datenbank und eines Persistenz-Frameworks werden sich nicht ändern. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Im Projekt wird die Persistierung mittels einer (oder mehrerer) Datenbank(en) erfolgen.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{e}{P\tone.\two}: Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus)}} }\s \\ [2ex]\hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Dieser Einflussfaktor resultiert aus unserer Entscheidung für die Strategie \glqq \hyperlink{yy}{GXL}\grqq{} zur Problemkarte \glqq Datensicherung/Persistenz des Graphen\grqq. Er besagt, dass es nötig ist, den Graphen (wie er in der GUI angezeigt wird) in ein GXL-Dokument zu schreiben dessen Inhalt dann als Text (varchar) in der embedded SQL-Datenbank gespeichert wird. Dieser Einflussfaktor thematisiert somit die Speicherung des Graphen als GXL Repräsentation in der Datenbank. Der Name dieses Einflussfaktors ist deshalb nicht entsprechend des eben beschriebenen Themas gewählt, da die Datenbank zusätzlich (wenn nicht sogar primär) der Speicherung der Nutzerinteraktionen dient.} }\rule{0pt}{11ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(++) Die Flexibilität dieses Einflussfaktors ist sehr hoch, da wir uns entschieden haben, die Anforderung des Speicherns und Laden des Graphen auf die beschriebene Weise zu lösen. Es ist also nicht vorgegeben diesen Ansatz zu wählen. Außerdem ist selbst bei der Entscheidung für diese Herangehensweise noch Flexibilität gegeben, beispielsweise für die Wahl des Tools oder die Entscheidung zur Selbsterstellung zur GXL-Dokument-Generierung und zum Speicherintervall. (Letzteres siehe unten). & 
	(-) Die Veränderlichkeit ist eher gering, da dieser Einflussfaktor die von uns gewählte Möglichkeit zur Umsetzung der eben genannten Anforderung zum Speichern/Laden des Graphen ist. Da dem Kunden die technische Umsetzung dieser Anforderung gleichgültig ist und wir denken, dass sich diese Anforderung auch nicht ändern wird, kommen wir zu dem Schluss, dass die Veränderlichkeit eher gering ist.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{In der von uns verwendeten embedded Datenbank wird neben den Nutzerinteraktionen als Commands auch eine Textrepräsentation des Graphen gespeichert.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{f}{P\tone.\two}: Betriebssystemunterstützung / Zielplattformen des Systems} }}\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Unser System muss mindestens auf den Betriebssystemen Windows 10, Linux und MacOS lauffähig sein. (Bei der Entwicklung von Apps für mobile Geräte kämen noch Android und iOS hinzu.)}}\rule{0pt}{5ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\ 
	(-) Bezüglich der Zielplattformen sind wir ziemlich unflexibel. Dies liegt daran, dass wir als Implementierungssprache Java in der Version 8 oder einer aktuelleren Variante vorgeschrieben bekommen haben und diese Programmiersprache den Aspekt der Lauffähigkeit bereits mit sich bringt. Somit bleibt uns nur noch die Wahl im Chinese Menue den Mobil-Punkt zu wählen, wodurch wir die Lauffähigkeit auf weiteren Betriebssystemen unterstützen müssten.&
	(--) Da mit den genannten Zielplattformen, insbesondere unter Einbezug der mobilen Systeme, die relevanten Systeme unterstützt werden, denken wir nicht, dass weitere Systeme unterstützt werden müssen. Der Wegfall eines der erwähnten Betriebssysteme hätte keine Folgen für unser Programm und ist unserer Meinung nach auch unwahrscheinlich. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir realisieren den Aspekt der Lauffähigkeit für die genannten Betriebssysteme durch Implementierung unserer Software in Java 8.} }\\[2ex] \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|}{\parbox{16cm} {\textbf{\hypertarget{g}{P\tone.\two}: Hohe Usability } }}\\ \hline\hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Wir streben eine hohe Usability für unser System an. Da dieses auch von Schüler/innen ab zehn Jahren benutzt werden wird, wollen wir die Bedienung möglichst intuitiv und die Benutzeroberfläche übersichtlich gestalten.} }\rule{0pt}{5ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Es sind keine Vorgaben an das Aussehen der Benutzeroberfläche oder deren technische Realisation gemacht worden. Dadurch haben wir eine große Auswahl an Gestaltungsmöglichkeiten. &
	(-) Die Anforderungen diesbezüglich werden sich nicht ändern. Ferner wird vermutlich keine Änderung an der GUI mehr gewünscht sein, wenn das System erst einmal im Einsatz ist oder zumindest der GUI-Prototyp mit dem Kunden abgesprochen ist. Denn sonst würde eine Umgewöhnung für die Nutzer erforderlich sein beziehungsweise würde man riskieren, dass der Auftraggeber nicht mit der entwickelten GUI einverstanden ist. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Die Wahl der von uns verwendeten Frameworks beziehungsweise Entscheidungen hinsichtlich der Gestaltungsweise der GUI wird durch diesen Einflussfaktor mitbestimmt. }}\\ \hline 
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{h}{P\tone.\two}: Hohe Qualität }} } \\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Im Rahmen der inneren Qualität streben wir eine hohe Änderbarkeit und Verständlichkeit des Quellcodes an. Die Änderbarkeit und folglich auch die Verständlichkeit soll insbesondere auch noch nach Abgabe der Software an den Kunden gegeben sein. Verständlichkeit meint in erster Linie die Eigenschaft unseres Quellcodes samt der dazugehörigen Dokumentation, dass dieser von einem anderen Entwickler mit geringem (Zeit-)Aufwand verstanden werden kann (und nicht von einem Laien im Bereich Software-Entwicklung). \\Im Rahmen der äußeren Qualität streben wir Fehlerfreiheit sowie eine hohe Bedienbarkeit an. Zu Letzterer haben wir aufgrund ihrer hohen Bedeutung und ihrer Vielschichtigkeit einen eigenständigen Einflussfaktor \hyperlink{g}{hohe Usability} erstellt. Aus diesem Grund wird die hohe Bedienbarkeit hier nicht weiter thematisiert. }  }\rule{0pt}{6ex}\\ [14ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Wie wir für eine hohe Verständlichkeit und Änderbarkeit sorgen wollen, ist uns überlassen. Ebenso sind uns keine genauen Vorgaben bezüglich der Gewährleistung der Fehlerfreiheit gemacht worden. &
	(-) Wir halten es für unwahrscheinlich, dass sich konkrete Vorgaben hinsichtlich Verständlichkeit und Änderbarkeit gemacht werden. Selbiges vermuten wir bezüglich der Fehlerfreiheit-Sicherstellung.   \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Diese Anforderung ist insofern von Relevanz, als dass die von uns verwendeten Frameworks gut verständlich oder gar selbstbeschreibend sein sollten. Sind die Frameworks nicht weitestgehend intuitiv verständlich sollten sie zumindest gut dokumentiert sein. Es liegt also eine gewisse Einschränkung bei unserer Tool-Wahl vor. Um die Verständlichkeit weiterhin sicher zu stellen, sollten wir unseren Code nicht nur dokumentieren, sondern die Architektur soweit möglich an bekannten Strukturen wie (\hyperlink{command}{Command},\hyperlink{bbb}{Model-View-Controller}) orientiert aufbauen.
			Außerdem müssen wir die Architektur so wählen, dass für Fehlerfreiheit gesorgt ist.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{i}{P\tone.\two}: Command }} } \\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Bei Command handelt es sich um ein Entwurfsmuster, das zum Aufbau einer Softwarestruktur genutzt werden kann, in der Commands (=Aktionen des Nutzers beziehungsweise Interaktionen des Nutzers mit dem System) als Objekte erfasst werden und somit eine zentrale Bedeutung in der Architektur besitzen. Die einzelnen Commands werden erfasst und können somit auch rückgängig gemacht werden (redo / undo). Dieses Entwurfsmuster wird durch unsere Entscheidung für die Strategie \hyperlink{command}{Command} (bei gleichzeitiger Umsetzung der Strategien \hyperlink{bbb}{Model-View-Controller} und \hyperlink{aadd}{Modularisierung}) bei der Problemkarte \glqq Auswahl der grundlegenden Softwarearchitektur\grqq{} zum Einflussfaktor. Denn es wirkt sich auf die genannte und die Problemkarte \glqq Persistierungsintervall des Graphen\grqq{} aus.} }\rule{0pt}{14.5ex}\\  \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Das Entwurfsmuster selbst legt zwar eine grobe Struktur nahe, da wir uns aber selbst für die Verwendung des Command-Patterns entschiedenen haben und wir die konkrete Commands / Nutzeraktionen selbst definieren können, schätzen wir die Flexibilität als eher hoch ein. Die Flexibilität ist nicht sehr hoch, weil die von uns entworfenen Commands konkret vorgegebene Anforderungen abdecken müssen. & 
	(o) Wir schätzen die Veränderlichkeit als neutral ein. Dies liegt daran, dass sich an der Verwendung des Entwurfsmusters Command und der sonstigen groben Softwarearchitektur vermutlich kaum etwas ändern wird, wenn die Software erst einmal im Betrieb ist. Allerdings könnten weitere Funktionen gefordert werden, die neue (also weitere) Commands / Nutzeraktionen erforderlich machen.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir werden Command-Objekte in unserer Datenbank speichern. Dies wirkt sich auf die Erstellung eines Protokolls von Nutzerinteraktionen aus und ist auch von Bedeutung für die grundlegende Softwarearchitektur.}}\\ [3ex]\hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{j}{P\tone.\two}: JavaFX }} } \\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Bei JavaFX handelt es sich um ein Framework, das die Erstellung von graphischen Benutzeroberflächen unterstützt. Besonders, im Vergleich zu anderen Oberflächengestaltungsframeworks und -sprachen, ist, dass die mit JavaFX erstellten Oberflächen sehr interaktiv sein können. JavaFX stellt außerdem Swing-Nodes zur Verfügung, in welche Swing-Komponenten eingefügt werden können. Damit stellt die Verwendung dieses Frameworks die Voraussetzung für den Einsatz von dem auf Swing basierenden JUNG-Framework dar.} }\rule{0pt}{10ex}\\ [7ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Die Verwendung von JUNG ist uns zwar nicht vorgeschrieben worden, wird von uns jedoch angestrebt. Da (wie eben beschrieben) JavaFX gut geeignet ist, um vom JUNG-Framework Gebrauch zu machen, wir die GUI aber auch auf eine andere Weise realisieren könnten - und somit in diesem Punkt eher flexibel sind - kommen wir insgesamt auf eine mittlere Flexibilität. &
	(--) Der Einsatz von JavaFX wird uns mit an Sicherheit grenzender Wahrscheinlichkeit nicht untersagt werden, sodass die GUI weiterhin damit umgesetzt werden kann. Ebenso wird Swing-Node, das die Basis für JUNG ist,  weiterhin auf JavaFX basieren.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir werden Teile unseres Systems - in erster Linie den Aufbau der GUI - mittels JavaFX realisieren. } }\\ [2ex]\hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{k}{P\tone.\two}: JUNG }} } \\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{JUNG (Java Universal Network/Graph) ist ein Framework, das wie der Name bereits erahnen lässt, der Erstellung von Graphen und dem Umgang mit denselben dient. Hierzu bietet es Implementierungen, die Funktionalität bereitstellen, um beispielsweise einen Graphen zu erzeugen und dessen Struktur zu analysieren. Dieser Einflussfaktor resultiert aus der Strategie JUNG, für die wir uns im Rahmen der Problemkarten \glqq Visualisierung, Editierung und Interaktion mit dem Graphen\grqq{} und \glqq Auswertung von Grapheigenschaften\grqq{}  entschieden haben.} }\rule{0pt}{9ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Da die Verwendung dieses Frameworks nicht vorgeschrieben ist, sondern eine Strategie von uns darstellt, um beispielsweise die geforderten Anforderungen bezüglich der Grapherstellung und Visualisierung umzusetzen, sind wir sehr flexibel, was die Verwendung dieses Frameworks angeht. Außerdem ist es uns überlassen, welche Teile des Frameworks wir einsetzen werden. Somit ist dieser Einflussfaktor sehr flexibel. & 
	(--) Da wir weder denken, dass dieses Framework zu einem beliebigem Zeitpunkt kostenpflichtig wird (was dazu führen würde, dass wir es im Rahmen des Moduls Softwareprojekt 2 nicht mehr verwenden dürften), noch glauben, dass Anforderungen hinzukommen, die den Einsatz des Frameworks auch für die bisherigen Anforderungen unmöglich macht, stufen wir die Veränderlichkeit als sehr gering ein. \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn {2}{|l|} {\parbox{16cm}{Wir werden wesentliche Bestandteile unserer Anwendung mit dem JUNG-Framework realisieren. JUNG ist ein Framework, welches bei der Visualisierung auf Swing-Komponenten aufbaut. Wir werden JUNG in unsere JavaFX Anwendung integrieren. } }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\setcounter{two}{1}
\subsubsection*{\hypertarget{l}{P\one}: System Funktionen}
\subsubsection*{\hypertarget{m}{P\tone.\two}: Basisfunktionen} 
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{n}{P\tone.\ttwo.\three}: Sphären}} } \\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Wie bei der Begriffserklärung zu \hyperlink{Sphaere}{Sphäre} beschrieben, sollen diese Flächen im Graphen als zusammenhängende, nicht-überlappende Bereiche dargestellt werden, die durch Linien voneinander abgetrennt werden.} }\rule{0pt}{5ex}\\ [2ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(-) Mit den möglichen visuellen Eigenschaften und Werten von Sphären halten wir diesen Einflussfaktor für eher unflexibel. & 
	(–) Da der \hyperlink{Syndromansatz}{Syndromansatz} ein Modell darstellt und Modelle im Allgemeinen nur dann einen weitreichenden Sinn haben, wenn sie beständig sind, gehen wir davon aus, dass sich die Anforderungen hierzu nicht ändern werden. Deshalb stufen wir die Veränderlichkeit als sehr gering ein.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{In unserem System muss es die Möglichkeit geben Sphären wie gefordert erstellen zu können, wobei Überlappungen automatisch vermieden werden. \\} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{o}{P\tone.\ttwo.\three}: Linienart/-dicke Kanten flexibel}} } \\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Diese Kanten, auf die sich dieser Einflussfaktor bezieht, sind die Kanten im Sinne der Relationen und nicht etwa die Linien, mit denen die Sphären voneinander abgetrennt werden. Die Linienarten sowie -dicken werden vom Kunden vorgegeben und sind fest. Das \glqq flexibel\grqq{} im Namen dieses Einflussfaktors stammt vom Plural \glqq Kantenarten\grqq / \glqq Kantendicken\grqq. Der Nutzer soll also aus einer fest definierten Vorauswahl wählen können. Die Farben der Kanten können jedoch frei von den Nutzern festgelegt werden.} }\rule{0pt}{11ex}\\ [9ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(--) Die Flexibilität dieses Einflussfaktors ist sehr gering. Dies liegt daran, dass sowohl die Linienarten als auch die Liniendicken genau vorgegeben werden. & 
	(--) Da es sich beim Syndromansatzes um ein Modell handelt (und ein Modell unserer Meinung nach nur mit einer gewissen Beständigkeit bezüglich Inhalt und Darstellung sinnvoll ist), denken wir nicht, dass sich die Vorgaben zu den Linieneigenschaften ändern werden. Deshalb stufen wir die Veränderlichkeit dieses Einflussfaktors als sehr gering ein. \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Die Kanten werden die vom Kunden geforderten Eigenschaften bezüglich Linienart und -dicke besitzen. \\} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{p}{P\tone.\ttwo.\three}: Typisierte Knoten}} } \\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die typisierten Knoten des Graphen sind wie oben beschrieben die \hyperlink{Symptom}{Symptome} gemäß des \hyperlink{Syndromansatz}{Syndromansatzes}. Jedes Symptom / jeder Knoten muss einer Sphäre zugeordnet sein.} }\rule{0pt}{4ex}\\ [2ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(-) Mit den möglichen visuellen Eigenschaften und Werten von Sphären halten wir diesen Einflussfaktor für eher unflexibel.& 
	(–) Da der \hyperlink{Syndromansatz}{Syndromansatz} ein Modell darstellt (und Modelle im Allgemeinen nur dann einen weitreichenden Sinn haben, wenn sie beständig sind), gehen wir davon aus, dass sich die Anforderungen hierzu nicht ändern werden. Deshalb stufen wir die Veränderlichkeit als sehr gering ein.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{In unserem System muss die Erstellung von Knoten (unter Zuweisung des Knoten zu einer Sphäre) möglich sein.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{q}{P\tone.\ttwo.\three}: Gerichtete Kanten (3 Relationstypen)}} } \\ \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Relationen sind gerichtete Kanten, die nicht am selben Knoten beginnen und einmünden. Das Ende einer Kante (jenes, das im Zielknoten mündet) wird, abhängig vom Relationstyp, durch eine spezielle Pfeilspitze dargestellt. Die Pfeilspitzen werden vom Kunden vorgegeben und sind fest. 
			Man unterscheidet zwischen drei Relationstypen: verstärkend mit einer eckigen Pfeilspitze, abschwächend mit einer runden Pfeilspitze und unbekannt mit einem Fragezeichen als Pfeilspitze.} }\rule{0pt}{10ex}\\ [7ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(–) Die Anzahl und das Aussehen der verschiedenen Relationstypen ist genau vorgegeben. Damit ist diese Anforderung unflexibel.&
	(–) Wir denken nicht, dass sich die Darstellung der bestehenden Relationstypen ändern oder einer der bestehenden Relationstypen wegfallen wird. Außerdem glauben wir nicht, dass ein oder mehr neue Relationstypen erforderlich werden. \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Im System muss es die drei Relationstypen geben, die wie gefordert dargestellt werden.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{r}{P\tone.\ttwo.\three}: Anzahl, Größe, Position, Farbe, Beschriftung der Sphären / Knoten / Kanten ist flexibel}} } \s \\ [1ex]  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Ein Nutzer kann im \hyperlink{``Vorlage bearbeiten''-Modus}{\glqq Vorlage bearbeiten\grqq-Modus} beliebig viele Sphären, Knoten und Kanten hinzufügen. Dabei ist für jedes eingefügte Graph-Element die Größe, die Position und die Beschriftung frei wählbar. Hiervon ausgenommen sind beispielsweise Versuche, Graph-Elemente so zu platzieren, dass sich Knoten oder Sphären überschneiden oder ein Knoten größer ist als die Sphäre, in der er sich befindet. Außerdem kann der Nutzer für jedes Element im Graphen aus einer Auswahl an Farben wählen. Im \hyperlink{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten\grqq-Modus} ist selbiges auch möglich, sofern nichts anderes in der Vorlage hinterlegt wurde.} }\rule{0pt}{11ex}\\ [10ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Es ist keine Vorgabe zur Umsetzung dieser Anforderung gemacht und auch nicht klar definiert, wie der Nutzer diese Grapheigenschaften ändern können soll (außer, dass das System leicht benutzbar sein soll). &
	(o) Die Möglichkeit zur Änderung visueller Eigenschaften soll sicherlich weiter bestehen. Es ist aber möglich, dass weitere Darstellungsoptionen wie zum Beispiel ein Blink-Effekt ausgewählt werden können sollen. \\ \hline 
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Im System muss eine Auswahl an graphischen Darstellungsaspekten existieren, die der Nutzer auf Teile des Graphen anwenden können soll.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{s}{P\tone.\ttwo.\three}: Ankerpunkte zw. Knoten und Kanten}} }\\ \hline\hline
	\multicolumn{2}{|l|}{\parbox{16cm}{An einem Knoten können beliebig viele Ankerpunkte angehängt werden (mit beliebig festlegbarer Position am Knotenrand). Über diese Ankerpunkte können Knoten über Relationen verbunden werden. Beim Verschieben eines Knoten (das nur innerhalb der Sphäre, in der sich der jeweilige Knoten befindet, möglich sein soll) wandert die Kante mit, wobei sie am Ankerpunkt hängen und der Relationstyp erhalten bleiben soll.} }\rule{0pt}{8ex}\\ [6ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Es handelt sich hierbei um eine recht konkrete Anforderung, die hinsichtlich der Benutzung weitgehend präzise beschrieben wurde. Dadurch sinkt unser Gestaltungsspielraum. &
	(o) Die Möglichkeit, dass sich diese Anforderung ändert und zum Beispiel auch Knoten über ihre Sphäre hinaus verschoben werden können, halten wir weder für besonders hoch noch für sehr niedrig. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Im System muss eine Auswahl an grafischen Darstellungsaspekten existieren, die der Nutzer auf Teile des Graphen anwenden können soll.}}\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{t}{P\tone.\ttwo.\three}: Zuordnung von Sphären und Knoten}} }\\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Jeder Knoten muss zwingend (genau) einer Sphäre zugeordnet sein. Der Knoten kann einer anderen Sphäre zugeordnet werden, sofern nichts anderes in der Vorlage hinterlegt wird. Ein Symptom wird immer genau in der Sphäre visuell dargestellt, wo der Knoten zugewiesen wurde.} }\rule{0pt}{6ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Es ist uns überlassen wie wir die eindeutige Zuordnung von Knoten zu einer Sphäre realisieren.& 
	(–) Wir denken nicht, dass sich diese Anforderung ändern wird, da dem Syndromansatz zufolge Symptome, die keiner Sphäre zugeordnet sind, nicht besonders sinnvoll sind.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Jedes Symptom, das vom Nutzer hinzugefügt wird, ist einer Sphäre zugeordnet. Wenn diese Zuordnung verändert werden soll, muss das Symptom zwingend einer anderen Sphäre zugeordnet werden.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\setcounter{three}{0}
\subsubsection*{\hypertarget{u}{P\tone.\two}: Erweiterte Graph-Funktionen}
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{v}{P\tone.\ttwo.\three}: Speicherung des Graphen}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Unser System muss eine Möglichkeit zur Verfügung stellen, mit der ein Nutzer, einen erstellten Graphen sowie eine Vorlage für einen Graphen speichern kann.} }\rule{0pt}{4ex}\\ [2ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(++) Uns ist weitestgehend freigestellt wie wir die vorgesehene Speicherung realisieren. Die Speicherung muss nicht einmal als Persistierung in einer Datenbank erfolgen, sodass wir die Flexibilität dieses Einflussfaktors als sehr hoch bewerten. &
	(o) Die Regelungen hinsichtlich dieser Anforderung werden sich voraussichtlich nicht ändern. Diese Vermutung wird dadurch gestützt, dass sich diese Anforderung nach genauer Absprache mit dem Kunden von einer ursprünglich anderen Anforderungsausgestaltung zur jetzigen geändert hat. Die jetzige Anforderung entspricht also dem, was der Kunde tatsächlich fordert. Ferner sollte dem Kunden die technische Umsetzung seiner Anforderung auch in Zukunft weitestgehend gleichgültig sein. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Die Architektur wird so entworfen, dass es möglich sein wird, einen Graphen auf eine noch (in diesem Dokument) festzulegende Weise zu speichern.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{w}{P\tone.\ttwo.\three}: Laden des Graphen}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{In unserem System wird es möglich sein, einen zuvor erstellten und gespeicherten Graphen sowie eine Vorlage für einen Graphen (die ebenfalls zuvor erstellt und gespeichert wurde) wieder zu laden und in unserem System anzuzeigen.} }\rule{0pt}{5ex}\\ [2ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Uns ist weitestgehend freigestellt wie wir das Laden eines vorab gespeicherten Graphen realisieren. Die Flexibilität ist dennoch nicht sehr hoch, da unsere Möglichkeiten des Ladens von der Umsetzung der Speicherung eingeschränkt werden. &
	(o) Die Regelungen hinsichtlich dieser Anforderung werden sich voraussichtlich nicht ändern. Diese Vermutung wird dadurch gestützt, dass sich diese Anforderung nach genauer Absprache mit dem Kunden von einer ursprünglich anderen Anforderungsausgestaltung zur jetzigen geändert hat. Die jetzige Anforderung entspricht also dem, was der Kunde tatsächlich fordert. Ferner sollte dem Kunden die technische Umsetzung seiner Anforderung auch in Zukunft weitestgehend gleichgültig sein. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Die Architektur des Systems muss so entworfen werden, dass es eine Möglichkeit zum Laden eines vorher gespeicherten Graphen beziehungsweise einer Graphvorlage gibt.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{x}{P\tone.\ttwo.\three}: Automatische Anordnung zur Übersichtlichkeit}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{In unserer Anwendung muss ein Algorithmus eingebaut sein, der eine möglichst übersichtliche Layout-Darstellung der Knoten und Kanten automatisch berechnet und den Graphen entsprechend darstellt. Knoten dürfen dabei die Sphären, der sie zugeordnet sind, nicht verlassen. (Im Chinese Menue ist dies die Anforderung O«Layout».)} }\rule{0pt}{7ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(++) Uns sind kaum Vorgaben gegeben, wie die optimale Darstellung auszusehen hat. Damit sind wir sehr flexibel in der Umsetzung dieser Anforderung.& 
	(-) Wir denken nicht, dass der Kunde später eine bestimmte Layout-Richtlinie oder etwas vergleichbares vorgibt, dem das vom Algorithmus berechnete Layout dann ähneln müsste. Dementsprechend werten wir die Veränderlichkeit als eher gering.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{In unserem System wird es einen Algorithmus geben, der die optimale Darstellung des Graphen - im Sinne einer größtmöglichen Übersichtlichkeit - berechnet und den Graphen entsprechend darstellt. Dies betrifft sowohl die Anordnung der Knoten in der Sphäre, der sie zugeordnet sind, als auch die Positionierung der Sphären im Graphen.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{y}{P\tone.\ttwo.\three}: Vorlage/Bearbeitsungsregeln}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Es soll im \hyperlink{``Vorlage bearbeiten''-Modus}{\glqq Vorlage bearbeiten\grqq-Modus (wie dort beschrieben)} die Möglichkeit geben eine Vorlage für ein Diagramm zu erstellen. Unter einer solchen Vorlage ist zu verstehen, dass eine Menge an Graph-Elementen (Sphären, Knoten und eventuell auch Kanten) in diesem Funktionsmodus erstellt wird und dann für jedes Attribut (zum Beispiel Position, Größe, Beschriftung, …) jedes erstellten Elements festgelegt werden kann, ob dieses Attribut im \hyperlink{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten\grqq-Modus} verändert werden darf oder nicht.} }\rule{0pt}{8ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Durch die Anforderungen des Kunden für jedes Attribut von jedem Element die Bearbeitungsmöglichkeit einzeln festlegen zu können besitzt dieser Einflussfaktor nur eine mittelmäßig hohe Flexibilität. &
	(-) Die Veränderlichkeit schätzen wir als eher gering ein, da es uns nicht sinnvoll und als unwahrscheinlich erscheint, die Möglichkeiten die ein Ersteller hat (die jetzt als sehr hoch geplant sind), einzuschränken.
	\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir müssen im \hyperlink{``Vorlage bearbeiten''-Modus}{\glqq Vorlage bearbeiten\grqq-Modus} eine Vorlage-Erstellen-Funktion bereitstellen, die sich auf die Bearbeitungsmöglichkeiten des Graphen im \hyperlink{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten\grqq-Modus} auswirkt.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular}{|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{z}{P\tone.\ttwo.\three}: Funktionsmodi (Ersteller, Bearbeiter, Auswerter)}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Das System muss eine Möglichkeit vorsehen, um die Interessen verschiedener Nutzer befriedigen zu können. Dabei sollen für unterschiedlichen Nutzergruppen (Ersteller \hyperlink{``Vorlage bearbeiten''-Modus}{(\glqq Vorlage bearbeiten\grqq-Modus)}, Betrachter \hyperlink{``Diagramm bearbeiten''-Modus}{(\glqq Diagramm bearbeiten\grqq-Modus)}, Auswerter \hyperlink{``Analyse''-Modus}{(\glqq Analyse\grqq-Modus)}) unterschiedliche Handlungsspielräume im System eingeräumt werden und unterschiedliche Informationen angezeigt bekommen.}} \rule{0pt}{8ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Uns wurden keinerlei Vorgaben zur Umsetzung dieser Funktion gemacht, wodurch wir allenfalls durch die Notwendigkeit des Wechsels zwischen verschiedenen Operationsmodi während der Systemnutzung eingeschränkt sind. Die Verfügbarkeit der verschiedenen Modi ist nicht diskutabel.&
	(+) Es könnte eventuell sein, dass noch eine oder mehrere verschiedene Operationsmodi benötigt werden. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|}{\parbox{16cm} {Es wird möglich sein, verschiedene Varianten unseres Systems auswählen zu können, die jeweils eine angepasste Auswahl an Funktionen bereitstellt.} }\\ \hline
\end{tabular}\\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{aa}{P\tone.\ttwo.\three}: Graph Visualisierung/ Interaktion/ Editierung}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Neben der im Einflussfaktor \glqq Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/ Kanten ist flexibel\grqq{} beschriebenen Erstellung von Graph-Elementen in (fast) beliebiger Menge und mit einer Vielzahl an möglichen Eigenschaftswerten (zum Beispiel Werte für Farbe, Größe, Position, ...) soll unser System auch die Editierung und Visualisierung von Graphen unterstützen. Mit Editierung ist gemeint, dass die erstellten Graph-Elemente auch wieder gelöscht werden können sollen und die Werte der Eigenschaften von jedem Graph-Element geändert werden können sollen. Im \hyperlink{``Vorlage bearbeiten''-Modus}{\glqq Vorlage bearbeiten\grqq-Modus} soll diese Bearbeitung uneingeschränkt möglich sein und im \hyperlink{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten\grqq-Modus} soll die Editierung im Rahmen der in der Vorlage hinterlegten Bearbeitungsregeln ebenfalls möglich sein. Mit der Visualisierung des Graphen ist gemeint, dass der Graph graphisch so dargestellt wird, wie es vom Nutzer festgelegt wird. Die Darstellung auf dem Bildschirm soll immer aktuell sein, sodass sich das Hinzufügen / Ändern / Löschen von Graph-Elementen direkt auf dem Bildschirm bemerkbar macht. Die Interaktion bezieht sich darauf, auf welche Art der Nutzer den Graphen bearbeiten kann. Zu der Interaktion gehört beispielsweise, dass der Nutzer einen Knoten durch Bewegen seiner Computermaus verschieben kann.} }\rule{0pt}{23ex}\\ [3ex] \hline
	\textbf{Flexibilität} & \textbf{Veränderlichkeit} \\
	(o) Durch die Vorgabe der existierenden Elemente eines Graphen (Sphären, Knoten und Kanten) und deren Eigenschaften, zum Beispiel Benennung und Farbe, sind wir nicht komplett flexibel. Durch die Freiheit bezüglich der Umsetzung dieser Eigenschaft, zum Beispiel auch die Wahl der vom Nutzer selektierbaren Farben, ist allerdings eine gewisse Flexibilität gegeben. & 
	(-) Da der \hyperlink{Syndromansatz}{Syndromansatz} als Modell Wert auf Vollständigkeit und Richtigkeit legen sollte, denken wir, dass keine weiteren Graph-Elemente oder Eigenschaften zu Graph-Elementen hinzukommen werden. \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Unser System muss so strukturiert werden, dass es die Erstellung von Graph-Elementen mit all ihren Eigenschaften und die Editierung und Löschung der Graph-Elemente unterstützt.}}\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{bb}{P\tone.\ttwo.\three}: Protokoll von Nutzerinteraktionen}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Um im \hyperlink{``Analyse''-Modus}{\glqq Analyse-Modus\grqq} die Interaktionen eines Nutzers mit dem System anzeigen zu können, müssen diese nachvollziehbar gemacht werden können. Hierbei geht es um die Interaktionen von Nutzern im \hyperlink{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten-Modus\grqq}. Bei den relevanten Aktionen handelt es sich beispielsweise um die Reihenfolge, in der ein Nutzer Symptome erstellt hat. Es sei noch einmal explizit erwähnt, dass es bei diesem Einflussfaktor ausschließlich um die Bereitstellung / Erstellung eines Protokolls der Nutzerinteraktionen geht. Die Speicherung letztgenannter und der Export / Import dieses Protokolls ist nicht Teil dieses Einflussfaktors.} }\rule{0pt}{11ex}\\ [9ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Uns ist komplett freigestellt wie wir diese Funktion realisieren. Als Einschränkung kann höchstens gesehen werden, dass diese Funktion (wie alle anderen auch) im Rahmen der hohen Usability gut verständlich genutzt werden können soll und wir somit nicht einfach den Datenbankinhalt anzeigen lassen können.&
	(-) Da wir diese Anforderung genau mit dem Kunden ausdiskutiert haben, entsprechen die Anforderungen an die im Protokoll angezeigten Informationen genau seinen Bedürfnissen. Dies wird dadurch bekräftigt, dass der Kunde schon Erfahrung mit der Verwendung des \hyperlink{Syndromansatz}{Syndromansatzes} im didaktischen Bereich hat und sich deshalb aller Wahrscheinlichkeit nach gründlich überlegt hat, welche Informationen für ihn relevant sind. Dementsprechend halten wir es für eher unwahrscheinlich, dass sich seine Wünsche hinsichtlich des Protokolls ändern werden. Somit stufen wir diesen Einflussfaktor als eher gering ein. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir werden eine den Kundenwünschen gemäße Funktion zur Bereitstellung eines Protokolls der Nutzerinteraktionen in unser System integrieren. Beim Entwurf der Architektur unserer Software wird dies berücksichtigt.}}\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{cc}{P\tone.\ttwo.\three}: Überlappung von Kantenenden und den Ansatzpunkten von Relationen}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Es darf keine Überlappung von Kantenenden geben, die am selben Knoten eingehen und verschiedene Relationstypen darstellen. Überlappung von Kantenenden desselben Relationstyps kann möglich sein. Überlappung von Startpunkten beliebiger Relationstypen kann möglich sein. Die Punkte, von denen Kanten ausgehen bzw. münden (Ankerpunkte), sollen so gewählt werden, dass die Darstellung möglichst übersichtlich ist.
			Relationen des gleichen Typs, die von oder zum gleichen Symptom laufen, werden gebündelt dargestellt (ggf. hierarchisch über Sphären; \hypertarget{Überlappung von Knotenenden des selben Relationstyps}{siehe Danny Holten (2006)}). (Letzteres ist im Chinese Menue die Anforderung O«Kantenbündelung».)} }\rule{0pt}{11ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(–) Die Anforderung ist sowohl hinsichtlich geforderter Funktion, Kantenbündelung bei gleichem Relationstyp, als auch hinsichtlich der Darstellung (siehe die angegebene Quelle) vorgegeben. Damit ist diese Anforderung nicht flexibel.& 
	(–) Da sich die Anforderung (insbesondere bezüglich der Darstellung) auf eine Quelle bezieht, obwohl diese zum jetzigen Zeitpunkt bereits über 10 Jahre alt ist, scheint die Anforderung recht beständig und damit nicht veränderlich zu sein.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir müssen eine Funktion zur Bündelung von Kanten des selben Relationstyps vorgeben. Die Architektur unserer Software muss diese Funktion unterstützen. Die Bündelung betrifft sowohl die Punkte an Knoten, an denen die Relationen ansetzen, als auch die Stellen, an denen sie an einem anderen Knoten münden.} }\\[5ex] \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\subsubsection*{\hypertarget{dd}{P\one}: Benutzeroberfläche}
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{ee}{P\tone.\two}: Zoom}} }\\ \hline\hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Das System soll es ermöglichen Teile des Graphen vergrößert darzustellen.}}\\ \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Es wurden kundenseitig keine Vorgaben zur Zoomstärke, zum Zoombereich oder zur Umsetzung gemacht. &
	(--) Die Notwendigkeit eines Zooms sowie die Freiheit bezüglich der Umsetzung werden voraussichtlich bestehen bleiben. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|}{\parbox{16cm} {Es muss eine Zoom-Funktion geben, die die Vergrößerung von Teilen eines Graphen ermöglicht. Diese Funktion muss bei dem Entwurf der Architektur eingeplant werden. }}\\ \hline
\end{tabular}
\\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{ff}{P\tone.\two}: Zoom.Kontext}} }\\ \hline\hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Ist der Zoom aktiviert, so soll ein Übersichtsfenster des gesamten Graphen eingeblendet sein, in dem erkenntlich wird, in welchem Bereich des Graphen man sich gerade befindet.}} \s\\ [1ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Uns sind an die Darstellung dieser Funktion kaum Vorgaben gemacht und bei der technischen Realisation sind wir absolut frei. &
	(--) Die Anforderungen an diese Funktionalität werden sich nicht ändern. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Das System muss eine Übersicht des Graphen in klein erstellen, sobald der Zoom aktiviert wird. Der Teil des Graphen, der einem Nutzer in vergrößerter Form dargestellt wird, muss identifiziert werden und ist in der Übersicht kenntlich zu machen. Dies muss beim Entwurf der System-Architektur eingeplant werden.} }\\ \hline
\end{tabular}
\\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{gg}{P\tone.\two}: Sprache}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Das System soll die Benutzung in mindestens zwei verschiedenen Sprachen unterstützen. Dies betrifft in erster Linie die Beschriftung der Elemente der GUI (im Chinese Menue die Anforderung Sprache) und in zweiter Linie die Beschriftungen (Namen, Beschreibungen; ...) der Elemente des Graphen (im Chinese Menue die Anforderung Sprache.Beschriftung).} }\rule{0pt}{7ex}\\ [1ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Es wurden keine Vorgaben zur Umsetzung und zur konkreten Anzahl von Sprachen gemacht. Es ist nur vorgegeben, dass es mindestens zwei sein müssen. &
	(o) Es könnte eine höhere Anzahl an Sprachen zu einem späteren Zeitpunkt gefordert werden. Allerdings ist dies eher unwahrscheinlich, da dem Kunden bereits eine Sprache gereicht hätte. Grund hierfür ist, dass der \hyperlink{Syndromansatz}{Syndromansatz} ein bislang nur in Deutschland genutztes Konzept ist. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Die Architektur unseres Systems muss so gewählt werden, dass die Beschriftung von Buttons und die Beschreibung von Dialogfeldern in verschiedenen Sprachen hinterlegt werden und vom Nutzer umgestellt werden kann.} }\\ \hline
\end{tabular}
%\\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{hh}{P\tone.\two}: Sprache.Beschriftung}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die Beschriftungen (Namen, Beschreibungen) der Graph-Bestandteile sollen in verschiedenen (das heißt in mindestens zwei unterschiedlichen) Sprachen hinterlegt werden können (im Chinese Menu die Anforderung Sprache.Beschriftung).} }\rule{0pt}{6ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Es wurden keine Vorgaben zur Umsetzung und zur konkreten Anzahl von Sprachen gemacht. Es ist nur vorgegeben, dass es mindestens zwei sein müssen. &
	(o) Es könnte eine höhere Anzahl an Sprachen zu einem späteren Zeitpunkt gefordert werden. Allerdings ist dies eher unwahrscheinlich, da dem Kunden bereits eine Sprache gereicht hätte. Grund hierfür ist, dass der \hyperlink{Syndromansatz}{Syndromansatz} ein bislang nur in Deutschland genutztes Konzept ist. \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Durch die Architektur unseres Systems muss die Erfüllung der Anforderung gewährleistet werden. Die Beschreibung von Graph-Elementen muss dementsprechend in verschiedenen Sprachen hinterlegbar sein und die in der GUI angezeigte Beschriftung soll vom Nutzer umgestellt werden können. \\ } }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\subsubsection*{\hypertarget{ii}{P\one}: Dateiformate}
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{jj}{P\tone.\two}: GXL-Export und -Import}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Unser System bietet die Möglichkeit einen im System erstellten Graphen im GXL-Format zu exportieren und diesen anschließend verlustfrei wieder importieren zu können. Verlustfrei wird damit gemeint, dass hinsichtlich der Darstellung und der hinterlegten Daten kein Unterschied zwischen dem Ursprungsgraphen und dem Graphen, der importiert wurde, besteht.} }\rule{0pt}{7ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Wir haben die Wahl, ob wir eine Bibliothek zur Realisierung dieser Anforderung verwenden oder sie durch Selbstprogrammieren umsetzen wollen. Allerdings ist als Graphaustauschformat GXL vorgeschrieben. &
	(-) Wir gehen nicht davon aus, dass ein anderes Austauschformat einen Mehrwert gegenüber GXL bringen würde, sodass wir davon ausgehen, dass sich diese Anforderung nicht ändern wird. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Unser System muss GXL-Dateien mit allen relevanten Informationen generieren können und darüber hinaus zu deren Ex- und Import in der Lage sein. All das muss beim Architektur.Entwurf berücksichtigt werden.}}\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{kk}{P\tone.\two}: PDF Erstellung}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Unser System bietet die Möglichkeit eine PDF zu erzeugen, deren Inhalt identisch zu dem in der GUI dargestellten Graphen ist. Die PDF ist also eine originalgetreu Abbildung des Graphen, den der Nutzer in unserem System erstellt hat.} }\rule{0pt}{6ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Uns ist zwar das Dateiformat vorgegeben, dass den Graphen originalgetreu abbilden soll, aber ansonsten sind wir in der Umsetzung der Anforderungen flexibel, da es mehrere Möglichkeiten gibt das geforderte PDF zu erstellen.& 
	(–) Da PDF (portable document format) ein weitverbreitetes Dateiformat ist, halten wir es für unwahrscheinlich, dass ein anderes Dateiformat gefordert wird, welches den Graphen darstellen soll.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir müssen in der Architektur eine Funktion einplanen, mit der der Nutzer den aktuell im System angezeigten Graphen als PDF speichern kann. } }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{ll}{P\tone.\two}: PDF drucken}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Es soll möglich sein, eine im PDF-Datei, die an einer beliebigen Stelle im Dateiverzeichnis im System des Nutzers gespeichert ist, aus unserem System heraus ausdrucken zu können.} }\rule{0pt}{4ex}\\ [2ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Uns sind keine Vorgaben hinsichtlich der Umsetzung der Dateisuche im Dateisystem und des Starten des Ausdrucks gemacht worden, weshalb dieser Einflussfaktor eher flexibel ist.& 
	(–) Da der Graph als PDF (portable document format) gespeichert werden soll (und wir denken, dass dieses Format dauerhaft verwendet werden soll), ist es naheliegend, dass weiterhin PDF-Dateien gedruckt werden können sollen. Wir denken außerdem nicht, dass sich der Kunde später für eine konkrete Umsetzung bezüglich der Bedienung wünschen wird - können dies aber auch nicht ausschließen. Deshalb stufen wir den Einflussfaktor als eher gering veränderlich ein.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{In unserem System kann der Nutzer den Befehl zum Druck einer lokal gespeicherten Datei geben. Die Architektur muss der Notwendigkeit dieser Anforderung Rechnung tragen.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{mm}{P\tone.\two}: Protokoll JSON}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die im \hyperlink{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten\grqq-Modus} aufgezeichneten Nutzerinteraktionen sollen sowohl in für Menschen lesbarer (also textueller) als auch in von Maschinen verarbeitbarer Form exportiert werden können.} }\rule{0pt}{5ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Wir haben recht umfangreiche Gestaltungsmöglichkeiten, wie wir das Protokoll ausgestalten. Dies gilt insbesondere für das Layout, in dem wir die Nutzerinteraktionen darstellen. Außerdem ist JSON lediglich die von uns gewählte Notation zur Realisierung des geforderten Im- und Exports von Nutzerinteraktionen (siehe Problemkarte \glqq Protokoll der Nutzerinteraktionen exportieren / importieren\grqq). Somit ist JSON nicht vom Kunden vorgeschrieben. &
	(-) Wir denken nicht, dass es zu einem späteren Zeitpunkt konkrete Wünsche des Kunden hinsichtlich der Form des Protokolls geben wird. Mit der Programmiersprachenunabhängigkeit ist außerdem auch langfristig für eine gute Auswertbarkeit der Information, die die JSON-Datei in sich trägt, gesorgt. \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Das Protokoll muss so in der verwendeten relationalen Datenbank gespeichert werden, dass es möglich ist, durch Anfragen an die Datenbank an die nötigen Informationen zu gelangen, um das Protokoll in den geforderten Formen zu erstellen.}}\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\subsubsection*{\hypertarget{nn}{P\one}: Auswertung/Analyse}
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{oo}{P\tone.\two}: Analyse des Graphen}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Im System ist es möglich besonders wichtige und/oder stark vernetzte Knoten geeignet hervorheben zu lassen. Wichtigkeit und Grad der Vernetzung können anhand der \hyperlink{Bedeutung eines Knoten}{oben genanten} Eigenschaften bestimmt werden. Diese Funktion soll im \hyperlink{``Vorlage bearbeiten''-Modus}{\glqq Vorlage bearbeiten \grqq-Modus} und im \hyperlink{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten\grqq-Modus} erreichbar sein. (Im Chinese Menue ist dies die Anforderung O«Analyse».)} }\rule{0pt}{7ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Der Kunde hat konkret angegeben, nach welchen Bedingungen die Wichtigkeit/Vernetztheit eines Knoten ermittelt werden soll. Ihm ist es allerdings egal wie das Ergebnis der Analyse visuell dargestellt wird.&
	(–) Wir denken, dass sich diese Anforderung nicht ändern wird, da unseres Verständnisses des Syndromansatzes nach mit den genannten Analysemöglichkeiten schon eine weitreichende Analyse der Vernetzung und Bedeutung einzelner Knoten möglich ist. \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir müssen die geforderten Analysefunktionen in den beschriebenen Funktionsmodi bereitstellen und diese dementsprechend bei unserem Architektur-Entwurf einplanen.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{pp}{P\tone.\two}: Auswertung des Graphen}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Im \hyperlink{``Analyse''-Modus}{\glqq Analyse\grqq-Modus} soll der Auswerter Statistiken über die \hyperlink{Bedeutung eines Knoten}{oben aufgeführten Maße} zur Wichtigkeit und zum Grad der Vernetzung von Knoten erhalten. (Im Chinese Menue ist dies die Anforderung O«Auswertung».)} }\rule{0pt}{5ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Da uns nur vorgegeben ist, zu welchen Daten wir Statistiken bereitstellen sollen, aber nicht wie die Statistiken umgesetzt/visuell dargestellt werden sollen, halten wir diese Anforderung für weder besonders flexibel noch für besonders unflexibel.& 
	(–) Wie im vorherigen Einflussfaktor erwähnt, denken wir nicht, dass weitere Analysemöglichkeiten zur Bestimmung von Wichtigkeit und Grad der Vernetzung eines Knotens hinzukommen. Ebenso denken wir nicht, dass der Kunde sich später eine konkrete Darstellung der Statistiken wünschen wird.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Es muss eine Funktion in die Architektur eingeplant und im späteren System bereitgestellt werden, die im Analyse-Modus das Einsehen von Statistiken zu den beschriebenen Knoteninformationen erlaubt.} }\\[3ex] \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{qq}{P\tone.\two}: Graph-Analyse mittels Graphmaße}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Im \hyperlink{``Analyse''-Modus}{\glqq Analyse\grqq-Modus} soll der Auswerter Informationen zu folgenden \hyperlink{Metriken}{Metriken/Graphmaßen (siehe oben)} angezeigt bekommen. (Im Chinese Menue ist dies die Anforderung O«Auswertung.Graphmaße».)} }\rule{0pt}{4ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(–) Da der Kunde hier konkrete Maße vorgibt und bei der visuellen Darstellung nur beschränkter Spielraum gegeben ist (anders als zum Beispiel bei Statistiken), halten wir diese Anforderung für eher unflexibel.& 
	(--) Wir denken nicht, dass der Kunde später weitere Metriken benötigt, deren Erfordernis er bisher nicht bemerkt hätte.\\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir müssen dem Auswerter die Gradmaße in einer angemessenen Form zur Verfügung stellen und diese Notwendigkeit bei unserem Architektur-Entwurf einbeziehen.} }\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{rr}{P\tone.\two}: Analyse über einen wählbaren Ausschnitt des Graphen}} } \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Knoten und Kanten können durch Betrachter selektiert werden und verschiedene Anfragen für die Selektion gestellt werden (Mehrfachselektion ist möglich; selektierte Knoten und Kanten werden geeignet visuell hervorgehoben):
			\begin{itemize}
				\itemsep-10pt
				\item alle von der Selektion erreichbaren Knoten und Kanten werden geeignet visuell hervorgehoben (mit und ohne Berücksichtigung der Kantenrichtung) \\
				\item alle Knoten und Kanten auf allen Wegen zwischen den selektierten Elementen werden geeignet visuell hervorgehoben (mit und ohne Berücksichtigung der Kantenrichtungen) \\
				\vspace{-0.4cm}
			\end{itemize}
			Die selektierten Knoten werden graphisch besonders hervorgehoben. Ob ein Knoten vorwärts oder rückwärts bei den oben genannten Anfragen erreichbar ist, soll geeignet visuell unterschieden werden; dabei ist zu beachten, dass ein Knoten zugleich vorwärts und rückwärts erreichbar und zugleich auch noch selektiert sein kann. Dies alles soll zugleich leicht visuell erkennbar sein.
			Sobald der Nutzer die Selektion wieder aufhebt, werden alle Knoten wieder einheitlich dargestellt. (Im Chinese Menue ist dies die Anforderung O«Ausschnitt».)} }\rule{0pt}{23ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Die geforderte Funktionalität ist recht genau beschrieben, während zur Darstellung (bis auf die Bedingung der Eindeutigkeit) keine Vorgaben gemacht wurden. Damit schätzen wir die Flexibilität als neutral ein.&
	(–) Wir denken nicht, dass in dieser Funktion eine Erweiterung sinnvoll einbaubar wäre, da mit der beschriebenen Funktion ein weit reichendes Analysieren der Knoten und Kanten möglich ist. Deshalb schätzen wir diesen Faktor als nicht veränderlich ein. \\
	\hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Unser System muss das geforderte Selektieren mit der (Erreichbarkeits-)Analyse und die visuelle Darstellung derselben unterstützen. Alle dafür erforderlichen Systembestandteile müssen in der Architektur eingeplant werden.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|}{\parbox{16cm} {\textbf{\hypertarget{ss}{P\tone.\two}: Filter von Knoten und Kanten}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Es soll die Möglichkeit geben, einen Graphen (genauer gesagt: Knoten und Kanten) nach bestimmten Merkmalen filtern zu können. Denkbare Filter wären dabei Relationstypen, reguläre Ausdrücke über Knotenbeschriftungen und manuelles Selektieren seitens des Betrachters. Die Auswahl wird angemessen dargestellt (z.B. durchs Ausgrauen oder unsichtbar-Machen)} }\rule{0pt}{7ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Der Kunde hat uns keine Vorgaben hinsichtlich der Darstellung der Auswahl der Knoten oder hinsichtlich des Filterergebnisses gemacht. Da auch keine Vorgaben zur Realisierung gemacht wurden, können wir zwischen verschiedenen Tools und einer eigenen Lösung wählen.  &
	(+) Es ist durch aus möglich, dass der Kunde weitere Filtermöglichkeiten zur Verfügung gestellt bekommen möchte.. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Im Entwurf der Architektur unseres Systems muss berücksichtigt werden, dass das fertige System verschiedene Optionen bereitstellen muss, nach denen ein aktuell dargestellter Graph gefiltert werden kann. Außerdem muss die visuelle Darstellung des Ergebnisses der Filterung geplant werden.} }\\ \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsubsection{Technische Faktoren}
\setcounter{one}{0}
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|}{\parbox{16cm} {\textbf{\hypertarget{tt}{T \one}: Hohe Fehlertoleranz}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Wir streben im Rahmen der hohen Usability (siehe Einflussfaktor \hyperlink{g}{P01.06: Hohe Usability}) für unser System auch eine hohe Fehlertoleranz an. Dabei wollen wir dem Nutzer frühzeitig anzeigen, wenn er fehlerhafte Eingaben tätigt und ihm deren Korrektur auch im Nachhinein mit geringst möglichem Aufwand ermöglichen.} }\rule{0pt}{7ex}\\ [3ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Wir sind frei in der Umsetzung dieser Anforderung und sie wurde durch die Forderung einer hohen Benutzbarkeit nur implizit genannt. &
	(-) Wir denken nicht, dass uns bezüglich der Fehlertoleranz und des maximalen Korrekturaufwandes konkretere Vorgaben gemacht werden. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|}{\parbox{16cm} {Wir werden ein System entwickeln, dass eine hohe Fehlertoleranz besitzt. Ausgeführte Aktionen sollten leicht rückgängig  gemacht werden können. Dies muss in der Architektur eingeplant werden. \\}}\\ [3ex]\hline 
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsubsection{Organisatorische Faktoren}
\setcounter{one}{0}
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{uu}{O \one}: Abgabedatum}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Die fertig dokumentierte Software muss inklusive Testprotokoll und Benutzerhandbuch bis zum 10.03.2019 abgegeben werden.} }\rule{0pt}{4ex}\\ [1ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(-) Da es sich bei dem Abgabetermin um eine Deadline handelt, dürfen wir die Software mit den anderen Abgaben auch schon vor dem oben genannten Datum überliefern. Die Deadline selbst ist allerdings nicht verhandelbar. &
	(--) Die Abgabetermin wird sich nicht verschieben. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Die Software wird spätestens am 10.03.2019 fertig implementiert, dokumentiert und getestet sein. Zunächst werden wir die Mindestanforderungen umsetzen. Erst danach wenden wir uns der Realisation von Punkten aus dem Chinese Menue zu. }}\\ [3ex]\hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color} \multicolumn{2}{|l|}{\parbox{16cm} {\textbf{\hypertarget{vv}{O \one}: Entwickler-Fähigkeiten} }}\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Unsere Fähigkeiten sind insofern von Relevanz, als dass sie festlegen, in welcher Qualität wir die Anforderungen umsetzen werden und welchen Funktionsumfang wir realisieren können.} }\rule{0pt}{4ex}\\ [1ex] \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Wir können uns durch Zuhilfenahme verschiedener Literatur weiterbilden und unsere Fähigkeiten ausbauen. &
	(+) Unser Tutor kann uns Tipps geben, wie man diverse Probleme, auf die wir während des Projekts stoßen können, lösen kann. Dies erweitert unser Denkspektrum und kann unsere Fähigkeiten ausbauen. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|}{\parbox{16cm} {Die Möglichkeiten zur Umsetzung der Anforderungen in hoher Qualität und Quantität steigen mit der Verbesserung unserer Fähigkeiten. }}\\ \hline
\end{tabular}
\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|}{\parbox{16cm} {\textbf{\hypertarget{ww}{O \tone}: Softwarelizenzbudget} }}\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Im Rahmen des Projektes dürfen wir nur kostenfreie Frameworks verwenden.} }\rule{0pt}{1ex}\\\hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(+) Es gibt viele kostenfreie Frameworks, aus denen wir wählen können. &
	(-) Die Regelungen hinsichtlich des Softwarelizenzbudgets werden sich nicht ändern. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|}{\parbox{16cm} {Es dürfen ausschließlich Frameworks verwendet werden, für die weder einmalig noch in regelmäßigen Abständen Kosten anfallen. Die Frameworks wiederum beeinflussen unsere Architektur.}}\\[1ex] \hline
\end{tabular}
%\\ \\ \\ \\ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\begin{tabular} {|p{8cm}|p{8cm}|}
	\hline
	\rowcolor{color}\multicolumn{2}{|l|} {\parbox{16cm}{\textbf{\hypertarget{xx}{O \tone}: Teamgröße}} }\\ \hline \hline
	\multicolumn{2}{|l|}{\parbox{16cm}{Wir müssen in diesem Modul mit einer Gruppe von sechs Leuten arbeiten.} }\rule{0pt}{1ex}\\ \hline
	\textbf{Flexibilität}  & \textbf{Veränderlichkeit} \\
	(o) Die Gruppengröße ist für den Beginn des Softwareprojektes auf sechs Personen festgelegt. Es könnte allerdings passieren, dass während des Semesters einige Mitglieder die Gruppe verlassen oder sich die Gruppe aufteilt. &
	(--) Es wird zu keiner Änderung bezüglich der Gruppengröße-Regelungen kommen. \\ \hline
	\multicolumn{2}{|l|} {\textbf{Auswirkungen}} \\
	\multicolumn{2}{|l|} {\parbox{16cm}{Wir müssen die Software-Architektur so wählen und die weiteren Abgabedokumente so strukturieren, dass es möglich ist, arbeitsteilig vorzugehen und jeder klar definierte, von anderen Aufgaben deutlich abgetrennte Aufgaben hat. Außerdem müssen wir im Rahmen der Gruppe arbeiten und können uns (mit Ausnahme der Unterstützung durch unseren Tutor) keine Hilfe von außen holen. Ferner wird der Umfang der Mindestanforderungen sinken, wenn ein oder sogar mehrere Mitglieder die Gruppe verlassen. }}\\ \hline
\end{tabular}\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage



\subsection{Probleme und Strategien}
\label{sec:strategien}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%1
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{01: Datensicherung/Persistenz des Graphen}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die Daten des Graphen müssen gespeichert werden. Das bezieht sich auf alle veränderlichen/unveränderlichen Eigenschaften der Knoten, Kanten und Sphären.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache}  & \hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}\\ 
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus} & \hyperlink {g}{Hohe Usability}\\
	\hyperlink {h}{Hohe Qualität} &
	\hyperlink {n}{Sphären} \\
	\hyperlink {o}{Linienart/-dicke Kanten flexibel}&
	\hyperlink {p}{Typisierte Knoten} \\
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen)} &
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} \\
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} &
	\hyperlink {t}{Zuordnung von Sphären und Knoten} \\
	\hyperlink {v}{Speicherung des Graphen} &
	\hyperlink {w}{Laden des Graphen} \\
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}&
	\hyperlink {hh}{Sprache.Beschriftung} \\
	\hyperlink {tt}{Hohe Fehlertoleranz} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{yy}{S1 - GXL}}}: \\
			Speichern des Graphen als GXL-Repräsentation (als text/plain) in einer Embedded Database (was dem Datentypen \texttt{varchar} entsprechend zu realisieren wäre). \\
			\textbf{S2 - BLOB NEO4J}: \\
			Speichern einer Neo4J-Database, die den Graphen beinhaltet. Der Graph selbst wird als BLOB (Binary Large Object) in einer Embedded Database gespeichert. \\
			\textbf{S3 - Datenmodell}: \\
			Erstellung eines eigenen Datenmodells für den Graphen. Das Datenmodell dient der Speicherung der Graph-Bestandteile (Sphären, Knoten und Kanten), deren Werten sowie der Beziehung der Graph-Elemente zueinander. Das Datenmodell wurde auf eine Embedded Database ausgelegt werden, in der dann dementsprechend der Graph abgespeichert wird.
	} }\\ [11ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink {ooo}{S43 - Eigener Datentyp}}&
	\textbf{\hyperlink {vvv}{S61 - Regeln in der GXL-Datei}} \\
	\textbf{\hyperlink {ttt}{S56 - Sourceforge Framework}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Wir haben uns für \cb{S1 - GXL} entschieden. \\ 
	Das Speichern einer \cb{NEO4J- DB als BLOB (S2)} ist problematisch, da diese Lösung besonders fehleranfällig ist. Durch einen Bitkipper in dem BLOB könnte es sein, dass wir die Datenbank nicht wieder herstellen könnten, was mit einem Datenverlust verbunden wäre. Auch wäre dieses Dateiformat nicht von \glqq außen\grqq{} einsehbar, da es große binäre Datenobjekte sind. Die Informationen zum Graphen, die als BLOB vorliegen, sind damit ausschließlich im engen System-Kontext nutzbar. Die Speicherung der Daten in einem BLOB in einer Embedded Database stellt ein Problem für uns dar, da wir keine Möglichkeit haben, Eigenschaften des Graphen einzusehen ohne das BLOB wieder umzuwandeln oder ohne die NEO4J Datenbank zu laden, in der der Graph zusätzlich gespeichert werden würde. Auch die Benutzer hätten bei einem Systemfehler keine Chance den Graphen von \glqq außen\grqq{} wiederherzustellen. \cb{S1 - GXL} bietet diese Möglichkeit, da wir die \cb{GXL} als text/plain in der Datenbank speichern. \\ 
	Der Vorteil von \cb{S3 - Datenmodell} ist, dass wir die Datenbank gezielt zu Grapheigenschaften abfragen können. Dieser Vorteil wird aber dadurch aufgehoben, dass eine Graphdatenbank diese Abfragen strukturierter verarbeiten kann und das eine Graphdatenbank schon vorgefertigte Algorithmen kennt. Dies würde wiederum für \cb{S2} sprechen. Diese Strategie besitzt jedoch die bereits genannten Nachteile. \\
	Mit der Entscheidung gegen \cb{S2} ist somit \cb{S1} für uns die am besten geeignete Strategie.
\end{onehalfspace}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%2
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{02: Persistierungsintervall des Graphen}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Der Graph muss innerhalb eines festgelegten Zeitintervalls persistiert/ abgespeichert werden.}}\rule{0pt}{1ex}\\  \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}&
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus}\\
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität}\\
	\hyperlink {i}{Command} & 
	\hyperlink {v}{Speicherung des Graphen} \\
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}  &  
	\hyperlink {tt}{Hohe Fehlertoleranz}    \\
	\hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{zz}{S4 - Command}}}: \\
			Persistierung des Graphen nach jedem Command. Das hieße, dass der Graph nach jeder Aktion, die ein Nutzer ausführt, gespeichert werden würde. \\
			\textbf{S5 - Benutzer}: \\
			Persistierung des Graphen nach Aufruf des Speicherbefehls durch den Benutzer. Bei Entscheidung für diese Strategie würde keine automatische Speicherung des Graphen stattfinden.
	} }\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink {aaa}{S7 - Datenmodell}} &
	\textbf{\hyperlink {command}{S9 - Command}}
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	\cb{S4 - Command} benötigt relativ wenig Ressourcen unseres Systems, obwohl bei dieser Strategie der Graph nach jedem Command geladen wird und in der Datenbank abgespeichert (unabhängig von unserer verwendeten Graphrepräsentation).
	Da dem Kunden aber eine hohe Usability zugesagt wurde, wird diese Strategie verfolgt. Wir nehmen hier dem Benutzer die Sorge, dass Daten verloren gehen könnten. \\
	\cb{S5 - Benutzer} wird demnach nicht verfolgt, da in diesem Fall der Benutzer selbst in der Verantwortung steht, die Speicherung regelmäßig durchzuführen. \\
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%3
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{03: Datensicherung/Persistenz der Nutzerinteraktionen}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die Daten der Nutzerinteraktion des Bearbeiters müssen abgespeichert werden.}}\rule{0pt}{1ex}\\  \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus} & 
	\hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}\\ 
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} & 
	\hyperlink {g}{Hohe Usability}\\
	\hyperlink {h}{Hohe Qualität} &
	\hyperlink {i}{Command} \\
	\hyperlink {n}{Sphären} &
	\hyperlink {o}{Linienart/-dicke Kanten flexibel} \\
	\hyperlink {p}{Typisierte Knoten} &
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen)} \\
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} &
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} \\
	\hyperlink {t}{Zuordnung von Sphären und Knoten} &
	\hyperlink {v}{Speicherung des Graphen} \\
	\hyperlink {w}{Laden des Graphen} &
	\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} \\
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung} &
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} \\
	\hyperlink {hh}{Sprache.Beschriftung} &
	\hyperlink {tt}{Hohe Fehlertoleranz} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{S6 - CSV}: \\
			Schreiben und Speichern der Nutzerinteraktionen in eine CSV Datei. \\
			\textbf{\cb{\hypertarget{aaa}{S7 - Datenmodell}}}: \\
			Speichern der Nutzerinteraktionen in der Embedded Database mit eigenem Datenmodell auf der Grundlage des Entwurfsmusters Command.}}\\ 
	\hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink {zz}{S4 - Command}} &
	\textbf{\hyperlink {command}{S9 - Command}} \\
	\textbf{\hyperlink {ppp}{S45 - H2 Database}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Es wird \cb{S7 - Datenmodell} umgesetzt. Die Nutzerinteraktionen in der Datenbank zu speichern, ermöglicht es, diese bei Bedarf durch Datenbankabfragen zu filtern. \cb{Das Datenmodell} ist dabei an das Entwurfsmuster Command angelehnt. Command ist eine grundlegende Strategie für die Softwarearchitektur unseres Systems, durch die die vom Benutzer aufgerufenen Kommandos an das System modelliert werden. Die Commands werden nach Ausführung durch den Benutzer in geeigneter Darstellung in die Datenbank geschrieben. \\
	Mit \cb{S6 - CSV} können wir ein ähnliches Schema für die Nutzerinteraktionen anlegen und so letztgenannte speichern. Die Datenbank aus \cb{S7} ermöglicht es (anders als \cb{S6}) aber diese geeigneter zu strukturieren und so Komplikationen zu vermeiden. Dadurch, dass eine Datenbank zur Persistierung der Nutzerinteraktionen verwendet werden muss, wäre \cb{S6} ohnehin keine legitime Option.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%4
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{04: Auswahl der grundlegenden Softwarearchitektur}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Wir müssen eine Architektur für unsere Software wählen, die durch das Zusammenspiel der grundlegenden Komponenten im System die Erfüllung aller Mindestanforderungen gewährleistet.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus} &
	\hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}\\ 
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}\\
	\hyperlink {h}{Hohe Qualität}&
	\hyperlink {i}{Command} \\
	\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)}  &
	\hyperlink {tt}{Hohe Fehlertoleranz} \\
	\hyperlink {uu}{Abgabedatum} &
	\hyperlink {vv}{Entwickler-Fähigkeiten} \\
	\hyperlink {xx}{Teamgröße} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{bbb}{S8 - MVC}}}: \\
			Dieses Design-Pattern sieht die Aufteilung des Systems in die drei grundlegenden Bestandteile Model, View und Controller vor. \\
			\textbf{\cb{\hypertarget{command}{S9 - Command}}}: \\
			Die Verwendung vom Command Designpattern sieht den Aufbau der Architektur derart vor, dass verschiedene Aktionen, die ein Nutzer ausführen kann, als Command-Objekte realisiert werden.\\
			\textbf{\cb{\hypertarget{aadd}{S10 - Modularisierung}}}: \\
			Die Gliederung des Systems in einzelne Module.
	} }\\ [8ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink {modelviewcontroller}{S13 - MVC}} &
	\textbf{\hyperlink {zz}{S4 - Command}} \\
	\textbf{\hyperlink {aaa}{S7 - Datenmodell}} &
	\textbf{\hyperlink {aabb}{S15 - Modularisierung}} \\
	\textbf{\hyperlink {aaaa}{S49 - Modularisierung}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Die Strategie \cb{S9 - Command} in das System zu integrieren erleichtert den Umgang mit den Kommandos des Benutzers an das System. Die Eingabebefehle des Benutzers, welche Auswirkung auf den Graphen und die Benutzeroberfläche haben, werden in Form von Commands strukuriert. Dies unterstützt die Implementierung von redo und undo, welche dem Benutzer für eine hohe Usability zur Verfügung gestellt werden können. \\
	Durch \cb{Model- View- Controller (S8)} wird den Entwicklern ein Grundgerüst gegeben, an dem sich orientiert werden kann. Es wird zwischen dem Datenmodell, der Präsentation und der Programmsteuerung differenziert und das System so übersichtlicher strukturiert. Dieser Ansatz sorgt also für hohe Wartbarkeit und Qualität. \\\
	\cb{S10 Modularisierung}, also die Zerlegung des Systems in kleine Grundbausteine als Module des Systems: Die Module sind weitestgehend voneinander entkoppelt, wodurch das System während der Entwicklungsphase und in den folgenden Phasen leichter erweitert und bearbeitet werden kann. \\
	Alle diese Strategien sollten während der Umsetzung des Projektes beachtet werden, da sie alle einen entscheidenden Einfluss auf die Qualität des Systems haben und sich problemlos kombinieren lassen. \\
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{05: Unerfahrene Entwickler}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Entwickler sind unerfahren in den verwendeten Technologien.}}\rule{0pt}{1ex}\\ \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {g}{Hohe Usability}\\
	\hyperlink {h}{Hohe Qualität}&
	\hyperlink {uu}{Abgabedatum} \\
	\hyperlink {vv}{Entwickler-Fähigkeiten} &
	\hyperlink {xx}{Teamgröße} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{ccc}{S11 - (System-) Biblotheken}}}: \\
			Das Nutzen von Bibliotheken unterstützt den Entwickler, da bereits bestehende Funktionen genutzt werden können.\\
			\textbf{\cb{\hypertarget{aaaf}{S12 - Dokumentierte Bibliotheken}}}: \\
			Dokumentierte Bibliotheken helfen bei der Verständnis von unbekannten Methoden \\
			\textbf{\cb{\hypertarget{modelviewcontroller}{S13 - MVC}}}: \\
			Verwendung Model- View- Controller Designpattern\\
			\textbf{\cb{\hypertarget{zeitmanagement}{S14 - Zeitmanagement}}}: \\
			Umsetzung eines effizienten Zeitmanagements, damit genug Zeit für die Entwickler zur Verfügung steht, sich in die benötigten Technologien einzuarbeiten.\\
			\textbf{\cb{\hypertarget{aabb}{S15 - Modularisierung}}}: \\%hypertarget already exists
			Die Gliederung des Systems in einzelne Module.
	} }\\ [9ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink {qqq}{S47 - Verwendung von (System-) Bibliotheken}} &
	\textbf{\hyperlink {aaaf}{S12 - Dokumentierte Bibliotheken}} \\
	\textbf{\hyperlink {ddd}{S16 - Dokumentierte Bibliotheken}} &
	\textbf{\hyperlink {ccc}{S11 - (System-) Bibliotheken}} \\
	\textbf{\hyperlink {qqq}{S47 - Verwendung von (System-) Bibliotheken}}& 
	\textbf{\hyperlink {ddd}{S16 - Dokumentierte Bibliotheken}} \\
	\textbf{\hyperlink {bbb}{S8 - MVC}} &
	\textbf{\hyperlink {aadd}{S10 - Modularisierung}} \\
	\textbf{\hyperlink {aacc}{S18 - Modularisierung}} &
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Eine Kombination aller Strategien wird hier umgesetzt. Die Verwendung von \cb{MVC} gibt den Entwicklern ein weitverbreitetes, ihnen bekanntes Grundgerüstes vor und ermöglicht es den Entwicklern, sich beim Entwurf und der Umsetzung eines detaillierten Software-Aufbaus an diesem Grundgerüst zu orientieren. \cb{(System) - Bibliotheken/ Dokumentierte Bibliotheken} unterstützen den Entwickler zusätzlich in der Entwicklungsphase.
	Durch \cb{Modularisierung} können geeignete Arbeitspakete auf die Entwickler verteilt werden, sodass sich ein Entwickler auf diese Teile fokussieren kann. \\ \\ \\ \\
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%6
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{06: Ausfallende Entwickler}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Teammitglieder können im Laufe der Entwicklung ausfallen.}}\rule{0pt}{1ex}\\ \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {g}{Hohe Usability}\\
	\hyperlink {h}{Hohe Qualität}&
	\hyperlink {uu}{Abgabedatum} \\
	\hyperlink {vv}{Entwickler-Fähigkeiten} &
	\hyperlink {xx}{Teamgröße} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{ddd}{S16 - Dokumentierte Bibliotheken}}}\\
			Bei der Wahl von Bibliotheken ist darauf zu achten, dass man deren Dokumentation in gut verständlicher Form erhalten kann. \\
			\textbf{\cb{\hypertarget{dokuvongeschriebenemcode}{S17 - Dokumentation von geschriebenem Code}}}\\
			Parallel zur Erstellung von Quell-Code wird deren Dokumentation geschrieben.\\
			\textbf{\cb{\hypertarget{aacc}{S18 - Modularisierung}}} \\
			Das System wird in kleinere Teile gegliedert und die Aufgaben können besser übernommen werden.
	}}\\ [4ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink {qqq}{S47 - Verwendung von (System-) Bibliotheken}} & 
	\textbf{\hyperlink {aaaf}{S12 - Dokumentierte Bibliotheken}} \\
	\textbf{\hyperlink {ccc}{S11 - (System-) Bibliotheken}} &
	\textbf{\hyperlink{aadd}{S10 - Modularisierung}}\\
	\textbf{\hyperlink{aabb}{S15 - Modularisierung}} &
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Im Fall des Ausfalles eines Entwicklers kann dessen Arbeitspaket vom System entkoppelt und separat behandelt werden (nach \cb{S18}). Falls das Arbeitspaket eines Entwicklers von einem anderen übernommen werden muss, hilft die Dokumentation (nach \cb{S17}) des bisher, vom ausgefallenen Teammitglied, erstellten Codes dem einspringenden Entwickler bei der Einarbeitung in das Arbeitspaket. Der schnelleren Einarbeitung wird durch Verwendung gut dokumentierter Bibliotheken weiter Rechnung getragen.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{07: Visualisierung, Editierung und Interaktion mit dem Graphen}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Das System muss den Graphen visualisieren. Dem Benutzer muss es möglich sein mit dem System zu interagieren und den Graphen zu editiert.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}\\ 
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität}\\
	\hyperlink {n}{Sphären} &
	\hyperlink {o}{Linienart/-dicke Kanten flexibel}\\
	\hyperlink {p}{Typisierte Knoten} &
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen} \\
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel}&
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} \\
	\hyperlink {t}{Zuordnung von Sphären und Knoten} &
	\hyperlink {v}{Speicherung des Graphen} \\
	\hyperlink {w}{Laden des Graphen} &
	\hyperlink {x}{Automatische Anordnung zur Übersichtlichkeit} \\
	\hyperlink {y}{Vorlage/Bearbeitsungsregeln} &
	\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} \\
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}&
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} \\
	\hyperlink {cc}{Überlappung von Kantenenden und den Ansatzpunkten von Relationen} &
	\hyperlink {ee}{Zoom} \\
	\hyperlink {ff}{Zoom.Kontext} &
	\hyperlink {hh}{Sprache.Beschriftung} \\
	\hyperlink {jj}{GXL-Export und –Import} &
	\hyperlink {oo}{Analyse des Graphen} \\
	\hyperlink {pp}{Auswertung des Graphen} &
	\hyperlink {qq}{Graph-Analyse mittels Graphmaße} \\ 
	\hyperlink {rr}{Analyse über einen wählbaren Ausschnitt des Graphen} &
	\hyperlink {ss}{Filter von Knoten und Kanten} \\
	\hyperlink {tt}{Hohe Fehlertoleranz} &
	\hyperlink {uu}{Abgabedatum} \\
	\hyperlink {vv}{Entwickler-Fähigkeiten} &
	\hyperlink {ww}{Softwarelizenzbudget} \\
	\hyperlink {xx}{Teamgröße} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{eee}{S19 - JUNG}}}: \\
			JUNG (Java Universal Network Graph Framework) ist eine open-source Softwarebibliothek, die eine Schnittstelle für die Modellierung, Analyse und Visualisierung von Daten bietet, die als Graph dargestellt werden können. \\
			\textbf{S20 - JGraphX, JGraphT}: \\
			JGraphT ist eine Java-Bibliothek mit graphentheoretischen Datenstrukturen und Algorithmen. JGraphX ist ein auf Swing- basierendes Framework zur Graphvisualisierung. \\
			\textbf{S21 - Ohne Framework}: \\
			Es wird kein Framework zur Unterstützung der Entwicklung eingesetzt. Die gesamte Funktionalität wird von den Entwicklern implementiert.
	} }\\ [11ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{fff}{S22 - JUNG}}&
	\textbf{\hyperlink{xee}{S54 - JUNG Layouts}}
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Die Graph Visualisierung/ Editierung und Interaktion wird mit Unterstützung des Frameworks \cb{JUNG (S19)} umgesetzt. JUNG bietet viele vorgefertigte Funktionen, wie beispielsweise die automatische Anordnung von Knoten oder die Bereitstellung von Sublayouts. Die Bibliothek ist gut dokumentiert, sodass den Entwicklern den Einstieg in das Framework leicht fällt. \\
	Durch die gegeben Vererbungshierarchie ist es leicht möglich Klassen mit eigene Funktionalität zu implementieren und dabei die bestehende Architektur anderer Klassen zu nutzen. \\
	\cb{JGraphX/ JGraphT} bieten ähnliche Funktionalität wie \cb{JUNG}. Allerdings stelle \cb{JGraphT} keine Möglichkeit Layout- Algorithmen zur Verfügung. Da unser System die Funktionalität zur Verfügung stellen soll, haben wir uns gegen S16 entschieden. Außerdem vereint JUNG die Funktionalität, die durch JGraphX, JGraphT zur Verfügung gestellt wird.\\
	\cb{JGraphT} stellt viele Algorithmen zur Graph Auswertung zur Verfügung, welche in \cb{JUNG} nicht ausreichend gegeben sind. Da grundsätzlich aber die Visualisierung des Graphen im Fokus steht, ist JUNG die bessere 
	\cb{Kein Framework} zu benutzen erhöht den Workload der Entwickler erheblich. Da wir nur begrenzte Zeit / Ressourcen zur Verfügung haben, entscheiden wir uns gegen \cb{S21}.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{08: Auswertung von Grapheigenschaften}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Der Graph muss bezüglich seiner Eigenschaften (Graphmaße, Umfang, Knotenbeziehungen) ausgewertet werden.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}\\
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität}\\
	\hyperlink {k}{JUNG} &
	\hyperlink {n}{Sphären} \\
	\hyperlink {p}{Typisierte Knoten} &
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen}\\
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} &
	\hyperlink {t}{Zuordnung von Sphären und Knoten} \\
	\hyperlink {v}{Speicherung des Graphen} &
	\hyperlink {w}{Laden des Graphen} \\
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}&
	\hyperlink {jj}{GXL-Export und –Import} \\
	\hyperlink {oo}{Analyse des Graphen} &
	\hyperlink {pp}{Auswertung des Graphen} \\
	\hyperlink {qq}{Graph-Analyse mittels Graphmaße} &
	\hyperlink {rr}{Analyse über einen wählbaren Ausschnitt des Graphen} \\ 
	\hyperlink {ss}{Filter von Knoten und Kanten} &
	\hyperlink {uu}{Abgabedatum} \\
	\hyperlink {vv}{Entwickler-Fähigkeiten} &
	\hyperlink {ww}{Softwarelizenzbudget} \\
	\hyperlink {xx}{Teamgröße} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{fff}{S22 - JUNG}}}: \\
			JUNG stellt bereits Klassen zur Verfügung, die ausgewählte Algorithmen auf Graphen implementieren. \\
			\textbf{S23 - NEO4J}: \\
			Die Erstellung einer temporären NEO4J Datenbank, welche den Graphen importiert. NEO4J stellt ausgewählte Algorithmen bereits zur Verfügung. \\
			\textbf{\cb{\hypertarget{eigeneImplementierung}{S24 - eigene Implementierung}}}: \\
			Die benötigten Algorithmen werden durch das Team implementiert.\\
			\textbf{\cb{\hypertarget{xxx}{S25 - JGraphT}}}:\\
			JGraphT stellt Algorithmen zur Berechnung von Grapheigenschaften bereit.
	} }\\ [11ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{eee}{S19 - JUNG}}&
	\textbf{\hyperlink{xee}{S54 - JUNG Layouts}}
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Die Funktionalität des Systems basiert bereits teilweise auf \cb{JUNG} basiert, weswegen des sehr praktisch wäre die von \cb{JUNG} zur Verfügung gestellten Algorithmen für die Graphauswertung zu benutzen. Diese Algorithmen decken aber nicht den Funktionsumfang den wir benötigen.\\
	Zur Graphrepräsentation verwenden wir im System GXL- Dateien, die in der Embedded Database gespeichert sind und klasseninterne Strukturen. Eine \cb{NEO4J Datenbank} zeitweise zu erstellen, welche ebenfalls die Daten des Graphs beinhaltet, erhöht die Fehleranfälligkeit unseres Systems, da alle Graphrepräsenationen zu jedem Zeitpunkt konsistent sein müssen. Deswegen entscheiden wir uns gegen \cb{S23}. \\
	\cb{JGraphT} implementiert die meisten Algorithmen, die wir für die Graphauswertung benötigen. Für die Visualisierung des Graphen haben wir uns zwar gegen JGraphT entschieden, dennoch bietet dieses Framework eine großes Potenzial in Bezug auf Graphalgorithmen. Deswegen werden wir JGraphT zur Unterstützung bei der Graphauswertung hinzuziehen. \\
	Algorithmen, die weder JGraphT, noch JUNG zur Verfügung stehen, werden die Entwickler implementieren.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{09: PDF Druck}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die visuellen Eigenschaften des Graphen sollen originalgetreu als PDF gedruckt werden können.}}\rule{0pt}{1ex}\\  \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}\\
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität}\\
	\hyperlink {kk}{PDF Erstellung} &
	\hyperlink {ll}{PDF drucken} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{ggg}{S26 - Java API}}}: \\
			Benutzung der Java API für Print Jobs. \\
			\textbf{S27 - Framework }: \\
			Eine open- source Bibliothek für den Druck einbinden.
	} }\\ [7ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{hhh}{S29 - java.awt.Graphics2D}} &
	\textbf{\hyperlink{iii}{S30 - Freeheb Vectorgraphics}}
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Da dem Benutzer eine hohe Usability zur Verfügung stehen soll, wird \cb{S27} nicht umgesetzt. Eine PDF zu exportieren und diese extern auszudrucken erfüllt nicht unsere Anforderungen. \\
	Mit Unterstützung der \cb{Java API} for Print Jobs ist es möglich PDF an einen Drucker zu schicken. \\
	Das Einsetzen einer externen Bibliothek die diese Aufgabe übernimmt ist zwar möglich, aber dadurch, dass wir die PDF \textit{nur} ausdrucken müssen und keine weitere Usablilty für den Druckvorgang zur Verfügung stehe muss, ist die Strategie \cb{S26} ausreichend.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%10
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{10: PDF Erstellung}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die visuellen Eigenschaften des Graphen sollen als PDF dargestellt werden können.}}\rule{0pt}{1ex}\\ \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &  
	\hyperlink {g}{Hohe Usability}\\
	\hyperlink {h}{Hohe Qualität} &
	\hyperlink {k}{JUNG} \\
	\hyperlink {n}{Sphären} &
	\hyperlink {o}{Linienart/-dicke Kanten flexibel}\\
	\hyperlink {p}{Typisierte Knoten} &
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen} \\
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} &
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} \\
	\hyperlink {t}{Zuordnung von Sphären und Knoten} &
	\hyperlink {v}{Speicherung des Graphen} \\
	\hyperlink {w}{Laden des Graphen} &
	\hyperlink {x}{Automatische Anordnung zur Übersichtlichkeit} \\
	\hyperlink {y}{Vorlage/Bearbeitsungsregeln} &
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}\\
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} &
	\hyperlink {cc}{Überlappung von Kantenenden und den Ansatzpunkten von Relationen} \\
	\hyperlink {hh}{Sprache.Beschriftung} &
	\hyperlink {oo}{Analyse des Graphen} \\
	\hyperlink {pp}{Auswertung des Graphen} &
	\hyperlink {rr}{Analyse über einen wählbaren Ausschnitt des Graphen} \\ 
	\hyperlink {ss}{Filter von Knoten und Kanten} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{S28 - JUNG}: \\
			JUNG bietet eine Möglichkeit den VisualisationViewer, welcher den Graphen visualisiert, als JPG zu speichern. Dieses Bild kann dann unter Verwendung eines Frameworks zur PDF Erstellung in eine PDF eingebettet werden. \\
			\textbf{\cb{\hypertarget{hhh}{S29 - java.awt.Graphics2D}}}: \\
			Verwendung einer Bibliothek, die es Java- Programmen, ausgehen von java.awt.Graphics2D, ermöglicht diese als PDF zu exportieren. \\
	} }\\ [4ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{iii}{S30 - Freeheb Vectorgraphics}}&
	\textbf{\hyperlink{ggg}{S26 - Java API}} 
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Die \cb{java.awt.Graphics2D} zu exportieren bietet eine höhere Qualität der Darstellung des Graphen. Die Möglichkeit, die von \cb{JUNG} zur Verfügung gestellt wird, entspricht nicht unseren qualitativen Ansprüchen, da die Qualität des Bildes nicht ausreichend ist. \\
	Um die Darstellung des Graphen von \cb{JUNG} losgelöst zu speichern, kann die \cb{java.awt.Graphics2D} exportiert werden. \cb{JUNG} bildet alle Grafikkontexte auf der \cb{java.awt.Graphics2D} ab, sodass dies machbar ist.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{11: Bibliothek für den PDF Export von java.awt.Graphics2D}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{java.awt.Graphics2D als PDF verlustfrei exportieren.}}\rule{0pt}{1ex}\\  \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {g}{Hohe Usability}\\
	\hyperlink {h}{Hohe Qualität}&
	\hyperlink {kk}{PDF Erstellung} \\
	\hyperlink {ww}{Softwarelizenzbudget} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{iii}{S30 - Freeheb Vectorgraphics}}}: \\
			Freeheb Vectorgraphics bietet eine umfangreiche Lösung um java.awt.Graphics2D als zahlreiche Formate (SVG, PDF) zu exportieren und eine einfache Schnittstelle für den Benutzer. \\
			\textbf{S31 - iText}: \\
			Das Framework iText erlaubt es Swing Komponenten als PDF zu speichern. \\
	} }\\ [5ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{hhh}{S29 - java.awt.Graphics2D}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Wir entscheiden uns für \cb{S30}, da dieses Framework die java.awt.Graphics2D in zahlreichen Formaten exportiert. Zusätzlich bietet das Framework bereits eine gute Schnittstelle für den Benutzer. \\
	\cb{iText} biete eine Lösung, in der Swing Komponenten in iText’s PdfGraphics2D überführt werden können. Diese Umsetzung biete allerdings den Nachteil, dass java.awt.Graphics2D nur als PDF gespeichert wird. Auch wird keine Benutzerschnittstelle geliefert. \\
	Die Lösung von Freeheb Vectorgraphics nimmt den Entwicklern mehr Aufwand ab und bietet zusätliche Features, deswegen wird Strategie \cb{S30} umgesetzt.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{12: Protokoll der Nutzerinteraktionen exportieren/ importieren}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Das System soll eine Möglichkeit bieten, das Protokoll der Nutzerinteraktionen von unserem System und der von uns verwendeten Datenbank losgelöst einsehen zu können (Export). Dieses Protokoll muss sowohl von Menschen lesbar als auch von einem Computer interpretiert werden können (Import).}}\rule{0pt}{7ex}\\ [4ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}\\ 
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität}\\
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{S32 - CSV} \\
			Die Nutzerinteraktionen könnten aus der Datenbank abgefragt und die aus der Datenbank erhaltenen Objekte könnten dann in je eine Zeile der Character-seperated-Value (CSV) -Datei geschrieben werden. Die Informationen / Werte der einzelnen Objekte würden dann entsprechend durch ein festzulegendes Zeichen voneinander getrennt werden. \\
			\textbf{\cb{\hypertarget{jjj}{S33 - JavaScript Object Notation (.json)}}} \\
			JSON ist eine Notation, die sowohl von Menschen gelesen als auch von Maschinen interpretiert werden kann. Dabei kann die Information (die in JavaScript Object Notation enthalten ist) von der Programmiersprache unseres Systems (Java) unabhängig gewonnen werden. Es ist also möglich eine JSON-Datei später beispielsweise über ein Python-Script einzulesen.
	} }\\ \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{www}{S63 - Jackson}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Wir entscheiden uns für \cb{S33}. Da wir in unserem Datenmodell für die Nutzerinteraktionen .json einbinden, um die Parameterwerte der Logs abzuspeichern, eignet es sich das gesamte Protokoll auch als .json zu importieren/ exportieren. \\
	\cb{S32} würde vom Prinzip auch funktionieren. Da das Datenmodell bereits .json einbindet und so wenig wie möglich verschiedene Dateiformate in unserem System eingebunden sein sollen, um Fehler zu vermeiden, entschieden wir uns gegen \cb{S32}.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{13: Benutzeroberfläche}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die Benutzeroberfläche bietet die Schnittstelle zwischen dem Benutzer und dem Graphen. Durch die GUI kann der Benutzer mit dem Graphen interagieren, diesen editieren und auswerten.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
	\hyperlink {c}{Verwendung von Maven als Build-System} \\
	\hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}&
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus}\\
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}&
	\hyperlink {g}{Hohe Usability}\\
	\hyperlink {h}{Hohe Qualität}&
	\hyperlink {i}{Command} \\
	\hyperlink {j}{JavaFX}&
	\hyperlink {k}{JUNG} \\
	\hyperlink {n}{Sphären} &
	\hyperlink {o}{Linienart/-dicke Kanten flexibel}\\
	\hyperlink {p}{Typisierte Knoten} &
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen} \\
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} &
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} \\
	\hyperlink {t}{Zuordnung von Sphären und Knoten} &
	\hyperlink {v}{Speicherung des Graphen} \\
	\hyperlink {w}{Laden des Graphen} &
	\hyperlink {x}{Automatische Anordnung zur Übersichtlichkeit} \\
	\hyperlink {y}{Vorlage/Bearbeitsungsregeln} &
	\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} \\
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}&
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} \\
	\hyperlink {cc}{Überlappung von Kantenenden und den Ansatzpunkten von Relationen} &
	\hyperlink {ee}{Zoom} \\
	\hyperlink {ff}{Zoom.Kontext} &
	\hyperlink {gg}{Sprache} \\
	\hyperlink {hh}{Sprache.Beschriftung} &
	\hyperlink {jj}{GXL-Export und –Import} \\
	\hyperlink {kk}{PDF Erstellung} &
	\hyperlink {ll}{PDF drucken} \\
	\hyperlink {mm}{Protokoll JSON} &
	\hyperlink {oo}{Analyse des Graphen} \\
	\hyperlink {pp}{Auswertung des Graphen} &
	\hyperlink {qq}{Graph-Analyse mittels Graphmaße} \\ 
	\hyperlink {rr}{Analyse über einen wählbaren Ausschnitt des Graphen} &
	\hyperlink {ss}{Filter von Knoten und Kanten} \\
	\hyperlink {tt}{Hohe Fehlertoleranz} &
	\hyperlink {uu}{Abgabedatum} \\
	\hyperlink {vv}{Entwickler-Fähigkeiten} &
	\hyperlink {ww}{Softwarelizenzbudget} \\
	\hyperlink {xx}{Teamgröße} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{kkk}{S34 - GUI Framework JavaFX}}} \\
			Es besteht die Möglichkeit für die Benutzeroberfläche JavaFX zu verwenden.  \\
			\textbf{S35 - GUI- Toolkit Swing} \\
			Die Benutzeroberfläche kann mit dem GUI-Toolkit von Swing erstellt werden.
	} }\\ \hline

\end{tabular}\\ \\ \\

\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{lll}{S36 - SwingNode}}&
	\textbf{\hyperlink{mmm}{S38 - Scene-Builder}}\\
	\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Die GUI wird mit \cb{JavaFX} umgesetzt. \\
	\cb{JavaFX} bietet mehr Möglichkeiten zur Anpassung der einzelnen GUI-Elemente. Das Aussehen kann durch CSS einfach umgesetzt werden. \\
	\cb{Swing} bietet auch alle Elemente, die wir benötigen, um unsere GUI zu modellieren. Allerdings kann das Aussehen der Elemente in \cb{Swing} nicht so gut beeinflusst werden wie mit \cb{JavaFX}. Ein Vorteil von \cb{Swing} wäre, dass der Graph in unserem System mit JUNG in \cb{Swing} modelliert wird und so eine einheitliches Benutzeroberfläche bilden würde. Allerdings vermitteln der Style, der durch Swing erzeugten Benutzeroberflächen den Eindruck eines veralteten Systems, da Frameworks wie \cb{JavaFX} die GUI- Oberfläche moderner wirken lassen. \\
	Da wir auch junge Menschen mit unserer Anwendung ansprechen möchten und \cb{JavaFX} eine bessere Usability bietet, entscheiden wir uns für \cb{S34}.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{14: Einbettung JUNG als Swing GUI- Framework in eine JavaFX Application}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Der Graph wird im System mit JUNG visualisiert. Dadurch, dass JUNG Swing Komponenten zur Visualisierung benutzt, die GUI aber mit JavaFX Komponenten modelliert wird, muss Swing in die JavaFX Anwendung eingebunden werden.}}\rule{0pt}{6ex}\\ [3ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} & 
	\hyperlink {g}{Hohe Usability}\\
	\hyperlink {h}{Hohe Qualität}&
	\hyperlink {j}{JavaFX}\\
	\hyperlink {k}{JUNG} &
	\hyperlink {tt}{Hohe Fehlertoleranz} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{lll}{S36 - SwingNode}}}: \\
			Der Graph-Editor sowie die Oberfläche der Graphauswertung werden mit JavaFX modelliert. Die Visualisierung des Graphen wird mit JUNG umgesetzt, welches sich um eine Swing- Framework handelt. JavaFX stellt Swing-Nodes zur Verfügung in die Swing Komponenten eingebettet werden können. 
			\\
			\textbf{S37 - Überschreibung von Klassen aus JUNG}: \\
			JUNG baut auf Swing - Komponenten auf. Eine Möglichkeit ist es Klassen des Visualisierungs- Moduls von JUNG zu überschreiben, sodass die Swing- Komponenten durch JavaFX- Komponenten ersetzt werden. \\
	} }\\ [11ex] \hline
\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{kkk}{S34 - GUI Framework JavaFX}}&
	\textbf{\hyperlink{ccc}{S11 - (System) Bibliotheken}}\\
	\textbf{\hyperlink{fff}{S22 - JUNG}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	\cb{S36} wird umgesetzt. JavaFX bietet eine fertige Lösung Swing- Komponenten zu integrieren. \cb{S37} umzusetzen ist viel aufwendiger und birgt ein hohes Fehlerpotenzial. Auch sind wir uns nicht sicher, ob \cb{S37} genauso umgesetzt werden könnte oder ob bei dem Prozess weiterer Probleme auftauchen würden. \\
	Deswegen entscheiden wir uns über die \cb{SwingNode}.    
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%15
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{15: Benutzeroberflächenerstellung mit JavaFX}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die Benutzeroberfläche wird mit JavaFX erstellt.}}\rule{0pt}{1ex}\\ \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} & 
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}\\
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität}\\
	\hyperlink {j}{JavaFX}&
	\hyperlink {tt}{Hohe Fehlertoleranz} \\
	\hyperlink {uu}{Abgabedatum} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{mmm}{S38 - Scene- Builder}}}: \\
			Mit Hilfe des Scene-Builders kann der Entwickler JavaFX Benutzeroberflächen zusammensetzen und diese als FXML exportieren.  \\
			\textbf{S39 - eigens implementieren}: \\
			Auf dem JavaFX- Framework aufbauend, wird die GUI von den Entwicklern implementiert.  \\
	} }\\ [6ex] \hline
\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{kkk}{S34 - GUI Framework JavaFX}}&
	\textbf{\hyperlink{lll}{S36 - SwingNode}}
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	\cb{S38} wird umgesetzt. Der \cb{Scene- Builder} exportiert alle von uns geforderten Elemente/ Funktionen an die GUI als FXML, welche in das System einfach integriert werden kann. Diese Funktionalität selber zu implementieren ist viel zeitaufwendiger. Da dem Team nur ein begrenzter Zeitraum/ Ressourcen zur Verfügung stehen, entscheiden wir uns gegen \cb{S39}. 
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{16: Begrenzter Funktionsumfang durch Bearbeitungszeit}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Durch den begrenzten Zeitraum unseres Projektes, können auch nur begrenzt Funktionen in unsere System eingebaut werden.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink {n}{Sphären} &
	\hyperlink {o}{Linienart/-dicke Kanten flexibel}\\
	\hyperlink {p}{Typisierte Knoten} &
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen} \\
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} &
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} \\
	\hyperlink {t}{Zuordnung von Sphären und Knoten} &
	\hyperlink {v}{Speicherung des Graphen} \\
	\hyperlink {w}{Laden des Graphen} &
	\hyperlink {x}{Automatische Anordnung zur Übersichtlichkeit} \\
	\hyperlink {y}{Vorlage/Bearbeitungsregeln} &
	\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} \\
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}&
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} \\
	\hyperlink {cc}{Überlappung von Kantenenden und den Ansatzpunkten von Relationen} &
	\hyperlink {ee}{Zoom} \\
	\hyperlink {ff}{Zoom.Kontext} &
	\hyperlink {gg}{Sprache} \\
	\hyperlink {hh}{Sprache.Beschriftung} &
	\hyperlink {kk}{PDF Erstellung} \\
	\hyperlink {ll}{PDF drucken} &
	\hyperlink {oo}{Analyse des Graphen} \\
	\hyperlink {pp}{Auswertung des Graphen} &
	\hyperlink {qq}{Graph-Analyse mittels Graphmaße} \\ 
	\hyperlink {rr}{Analyse über einen wählbaren Ausschnitt des Graphen} &
	\hyperlink {ss}{Filter von Knoten und Kanten} \\
	\hyperlink {uu}{Abgabedatum} &
	\hyperlink {vv}{Entwickler-Fähigkeiten} \\
	\hyperlink {ww}{Softwarelizenzbudget} &
	\hyperlink {xx}{Teamgröße} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{nnn}{S40 - erweiterte Anforderungen}}}: \\
			Mindestanforderungen des Projektes und zusätzliche Anforderungen (Chinese Menue) werden so umgesetzt, dass diese den Ansprüchen der Gruppe und des Tutors genügen. \\
			\textbf{S41 - Mindestanforderungen}: \\
			Nur die Mindestanforderungen werden umgesetzt. \\
	} }\\ [6ex] \hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	\cb{S40} wird umgesetzt, da wir versuchen wollen, die uns bestmögliche Umsetzung zu erarbeiten. Nur die Mindestanforderungen zu erfüllen, entspricht nicht den Ansprüchen des Teams.
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{17: Protokolldaten und Graphdaten zusammen sichern}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die Nutzerinformationen (das Protokoll) muss genauso wie der Graph gesichert werden. Hierzu wäre es sinnvoll, die Daten nach einer geeigneten Strategie zusammen zu speichern.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} & \hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}\\ 
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus}&
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}\\
	\hyperlink {h}{Hohe Qualität} &
	\hyperlink {v}{Speicherung des Graphen} \\
	\hyperlink {w}{Laden des Graphen} &
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} \\
	\hyperlink {jj}{GXL-Export und –Import} & 
	\hyperlink {vv}{Entwickler-Fähigkeiten}
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{S42 - Datenordner}: \\
			Dateien in einem Ordner (ggf. ZIP) ablegen/packen. \\
			\textbf{\cb{\hypertarget{ooo}{S43 - Eigener Datentyp}}}: \\
			Speicherung beider Daten in einer Textdatei als ein eigener Dateityp \\
	} }\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{yy}{S1 - GXL}}&
	\textbf{\hyperlink{vvv}{S61 - Regeln in der GXL-Datei}}\\
	\textbf{\hyperlink{ttt}{S56 - Sourceforge Framework}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Wir haben uns für \cb{S43} entschieden, da die Daten bereits in Textform vorliegen und wir unsere Daten möglichst sauber abspeichern wollen, welches bei 42 nicht gegeben ist.
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{18: Verwendung einer Embedded Database}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Wir benötigen eingebettete Datenbanken für das Protokoll und für den Graphen.}}\rule{0pt}{1ex}\\  \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} & \hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}\\ 
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus}&
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}\\
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität} \\
	\hyperlink {v}{Speicherung des Graphen} &
	\hyperlink {w}{Laden des Graphen} \\
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} &
	\hyperlink {jj}{GXL-Export und –Import} \\
	\hyperlink {vv}{Entwickler-Fähigkeiten} &
	\hyperlink {ww}{Softwarelizenzbudget} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{S44 - SQLite}: \\
			Verwendung von SQLite als eingebettete Datenbank \\
			\textbf{\cb{\hypertarget{ppp}{S45 - H2 Database}}}: \\
			Verwendung von H2 als eingebettete Datenbank \\
			\textbf{S46 - Apache Derby}: \\
			Verwendung von Apache Derby als eingebettete Datenbank \\
	}}\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{aaa}{S7 - Datenmodell}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Wir haben uns gegen S44 entschieden, da Hibernate hierfür nicht ausgelegt ist. Hierzu wäre es nötig, einen eigenen Sequeldialekt zu entwickeln. Für uns bietet die \cb{S45} alle Funktionen, die wir benötigen. S46 dagegen hat den Nachteil, dass die Performanz (bei von uns getesteten Speicheraktionen) nicht ganz so hoch war wie bei S45.
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{19: Einhaltung der Abgabetermine}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die Abgabetermine sind nicht verhandelbar. Da die Ressourcen begrenzt sind benötigen wir Strategien um Deadlines einzuhalten.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität}\\
	\hyperlink {uu}{Abgabedatum} &
	\hyperlink {vv}{Entwickler-Fähigkeiten} \\
	\hyperlink {xx}{Teamgröße} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{qqq}{S47 - Verwendung von (System -) Bibliotheken}}}: \\
			Durch das Verwenden von Bibliotheken sparen wir Aufwand und damit Zeit, indem wir bereits bestehende Funktionen benutzen. \\
			\textbf{\cb{\hypertarget{aaab}{S48 - Wiederverwendung von System-eigenen Komponenten}}}: \\
			Das Wiederverwenden von System-eigenen Komponenten ist sinnvoll, um Ressourcen zu sparen. \\
			\textbf{\cb{\hypertarget{aaaa}{S49 - Modularisierung}}}: \\
			Durch ein modularisiertes System lassen Arbeitspakete auf das Team so aufteilen, dass jedes Teammitglied ein bewältigbaren Workload hat. Dadurch entsteht ein geregelter und effizienter Arbeitsablauf. \\
	} }\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{aadd}{S10 - Modularisierung}}&
	\textbf{\hyperlink{aaaf}{S12 - Dokumentierte Bibliotheken}}\\
	\textbf{\hyperlink{aabb}{S15 - Modularisierung}}&
	\textbf{\hyperlink{ddd}{S16 - Dokumentierte Bibliotheken}}
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Aufgrund der Wichtigkeit dieses Problems entscheiden wir uns dafür, \cb{S47}, \cb{S48} und \cb{S49} umzusetzen. Dies sorgt dafür, dass wir Ressourcen sparen und unser Arbeitsablauf geregelt wird.
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%20
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{20: Kommunikation Zielplattform (Java) mit embedded DB}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Es ist erforderlich die Objekte des Nutzerprotokolls, die während der Nutzung unseres System erstellt werden, in einer Datenbank zu speichern. Dazu muss aus dem Objekt im Java-Kontext ein Datenbankeintrag erstellt werden. Hierfür ist Obejct-relational-Mapping (ORM) erforderlich.}}\rule{0pt}{6ex}\\ [3ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} & 
	\hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}\\ 
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus}&
	\hyperlink {f}{Betriebssystemunterstützung / Zielplattformen des Systems}\\
	\hyperlink {h}{Hohe Qualität}&
	\hyperlink {i}{Command} \\
	\hyperlink {v}{Speicherung des Graphen} &
	\hyperlink {w}{Laden des Graphen} \\
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} &
	\hyperlink {tt}{Hohe Fehlertoleranz} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{rrr}{S50 - Hibernate}}}: \\
			Verwendung von Hibernate als Persistenz- und ORM-Framework. \\
			\textbf{S51 - Toplink (Oracle), nun EclipseLink}: \\
			Verwendung von EclipseLink als Persistenz- und ORM-Framework. \\
			\textbf{S52 - Apache OpenJPA}: \\
			Verwendung con Apache OpenJPA als Persistenz-Framework.
	} }\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{aaa}{S7 - Datenmodell}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Durch die Verwendung der vorgeschlagenen ORM-Framworks werden zum Beispiel mittels Annotationen im Quellcode SQL-Queries erzeugt, die direkt mit der DB kommunizieren können. Hibernate ist der Standard, wenn es um Open-Source ORM geht. Dieses Tool ist gut dokumentiert und es finden sich zahlreiche Codebeispiele.
	Gegen OpenJPA spricht, die mangelnde ORM-Funktionalität, die unnötigen Mehraufwand für uns verursachen würde. \\
	An EclipseLink kann kritisiert werden, dass durch den Wechsel vom früheren Toplink zur jetzigen Form Recherchen bei auftretenden Problemen erschwert werden, da die gefundenen Lösungen zu Toplink mitunter nicht auf EclipseLink übertragbar sind.
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{21: Übersichtlichkeit in der Sphäre und im Graphen}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Die Knoten/ Kanten werden in der Sphäre und in dem Graphen übersichtlich angeordnet, sodass sich möglichst wenig Kanten verschiedenen Typs überschneiden und die Knoten übersichtlich angeordnet sind.}}\rule{0pt}{6ex}\\ [3ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {h}{Hohe Qualität}\\
	\hyperlink {n}{Sphären} &
	\hyperlink {o}{Linienart/-dicke Kanten flexibel}\\
	\hyperlink {p}{Typisierte Knoten} &
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen} \\
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} &
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} \\
	\hyperlink {t}{Zuordnung von Sphären und Knoten} &
	\hyperlink {v}{Speicherung des Graphen} \\
	\hyperlink {w}{Laden des Graphen} &
	\hyperlink {x}{Automatische Anordnung zur Übersichtlichkeit} \\
	\hyperlink {y}{Vorlage/Bearbeitsungsregeln} &
	\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} \\
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}&
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} \\
	\hyperlink {cc}{Überlappung von Kantenenden und den Ansatzpunkten von Relationen} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{sss}{S53 - Layouts in Layouts}}}: \\
			Unterteilung in 2 Layouts. Eines um das Layout innerhalb der Sphären zu berechnen und ein weiteres, um die beste Anordnung der Sphären zu berechnen. \\
			\textbf{\cb{\hypertarget{xee}{S54 - JUNG Layouts}}}: \\
			Von JUNG zur Verfügung gestellte Layouts einbinden. \\
			\textbf{\cb{\hypertarget{xff}{S55 - Eigenes Layout}}}: \\
			Layout selber erstellen
	} }\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{eee}{S19 - JUNG}}&
	\textbf{\hyperlink{fff}{S22 - JUNG}}
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Wir haben uns für die Verwendung von \cb{S53}, \cb{S54} und \cb{S55} entschieden, da die Funktionen von JUNG für unseren Anwendungsfall nicht ausreichend sind, aber dennoch eine gute Ausgangslage bieten. Die (bei JUNG) fehlenden Funktionen werden durch die Strategien S53 und S55 ergänzt.
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{22: GXL Erstellung}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Es soll eine Graph-Repräsentation in der Graph eXchange Language erstellt werden.}}\rule{0pt}{1ex}\\ \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache}  & 
	\hyperlink {e}{Benutzung einer leichtgewichtigen relationalen Datenbank (über die Nutzerinteraktion-Persistierung hinaus}\\ 
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {n}{Sphären} \\
	\hyperlink {o}{Linienart/-dicke Kanten flexibel}&
	\hyperlink {p}{Typisierte Knoten} \\
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen} &
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} \\
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} &
	\hyperlink {t}{Zuordnung von Sphären und Knoten} \\
	\hyperlink {v}{Speicherung des Graphen} &
	\hyperlink {w}{Laden des Graphen} \\
	\hyperlink {hh}{Sprache.Beschriftung}&
	\hyperlink {jj}{GXL-Export und –Import}
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{ttt}{S56 - Sourceforge Framework}}}: \\
			Die Verwendung des GXL-Frameworks von Sourceforge zur Erstellung von GXL-Dateien \\
			\textbf{S57 - Arakhne Framework}: \\
			Die Verwendung des GXL-Frameworks von Arakhne zur Erstellung von GXL-Dateien \\
			\textbf{S58 - Eigene GXL-Erstellung}: \\
			Die eigener Entwicklung eines Programms zur Erstellung von GXL-Dateien 
	} }\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{yy}{S1 - GXL}}&
	\textbf{\hyperlink{vvv}{S61 - Regeln in der GXL-Datei}}
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	S58 würde viel zu viel Ressourcen kosten, welche überhaupt nicht gerechtfertigt sind, da es bereits Frameworks gibt. S57 erfordert noch weitere Entwicklung um unsere Anforderungen abzudecken. \cb{S56} deckt unsere Anforderungen ab und ist einfacher zu bedienen.
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{23: Umsetzung der Funktionsmodi}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Dem Benutzer ist es freigestellt mehrere Modi in unserem System zu benutzen (Ersteller, Bearbeiter, Auswerter).}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink {g}{Hohe Usability}&
	\hyperlink {hh}{Sprache.Beschriftung} \\
	\hyperlink {v}{Speicherung des Graphen} &
	\hyperlink {w}{Laden des Graphen} \\
	\hyperlink {x}{Automatische Anordnung zur Übersichtlichkeit} &
	\hyperlink {y}{Vorlage/Bearbeitungsregeln} \\
	\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} &
	\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}\\
	\hyperlink {bb}{Protokoll von Nutzerinteraktionen} &
	\hyperlink {cc}{Überlappung von Kantenenden und den Ansatzpunkten von Relationen} \\
	\hyperlink {oo}{Analyse des Graphen} &
	\hyperlink {pp}{Auswertung des Graphen} \\
	\hyperlink {qq}{Graph-Analyse mittels Graphmaße} & 
	\hyperlink {rr}{Analyse über einen wählbaren Ausschnitt des Graphen} \\ 
	\hyperlink {ss}{Filter von Knoten und Kanten} &
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{uuu}{S59 - Modi als eigener Teil unserer Applikation}}}: \\
			Umsetzung der Modi programmintern als eigenes Modul, je nachdem welcher Modi gesetzt ist, wird die GUI dargestellt und bestimmte Funktionen zur Verfügung gestellt \\
			\textbf{S60 - Ein Programm pro Modus}: \\
			Auswahl des Modus beim Start des Programms, wodurch verschiedene Anwendungen gestartet werden können
	} }\\ [7ex] \hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	S60 ist für unsere Anforderungen unpraktisch und sorgt für eine schlechte Usability. Durch \cb{S59} dagegen lässt sich angenehm zwischen verschiedenen Modi umschalten. 
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{24: Vorlage}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Es muss eine Vorlage eines Graphen erstellt werden können, welche schon Graphelement beinhaltet, sowie die Möglichkeit bietet, Regeln für die Grapherstellung festzulegen.}}\rule{0pt}{4ex}\\ [1ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache}  & 
	\hyperlink {n}{Sphären} \\
	\hyperlink {o}{Linienart/-dicke Kanten flexibel}&
	\hyperlink {p}{Typisierte Knoten} \\
	\hyperlink {q}{gerichtete Kanten (3 Relationstypen} &
	\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} \\
	\hyperlink {s}{Ankerpunkte zw. Knoten und Kanten} &
	\hyperlink {t}{Zuordnung von Sphären und Knoten} \\
	\hyperlink {v}{Speicherung des Graphen} &
	\hyperlink {w}{Laden des Graphen} \\
	\hyperlink {y}{Vorlage/Bearbeitungsregeln} &
	\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} \\
	\hyperlink {hh}{Sprache.Beschriftung} &
	\hyperlink {jj}{GXL-Export und –Import} 
	\\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{vvv}{S61 - Regeln in der GXL-Datei}}}: \\
			Die Regelfestlegung wird in der GXL-Datei abgespeichert. \\
			\textbf{S62 - Externe Regelabspeicherung}: \\
			Die Regeln werden extern abgespeichert und beim Laden ausgelesen. 
	} }\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{yy}{S1 - GXL}}&
	\textbf{\hyperlink{ooo}{S43 - Eigener Datentyp}}\\
	\textbf{\hyperlink{ttt}{S56 - Sourceforge Framework}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Wir entscheiden und für \cb{S61}, da wir sowieso dauerhaft mit der GXL-Repräsentation interagieren. S2 bringt uns keinen Vorteil und es entsteht nur eine Datei mehr, mit der interagiert werden muss. 
\end{onehalfspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%25
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
\hline
\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{25: Persistierung der Parameter in die DB als JSON-String}}} \\ \hline\hline 
\multicolumn{2}{|l|}{\parbox{16cm}{Wir müssen alle für das Protokoll der Nutzerinteraktionen als Log nötigen Informationen von den Parameter-Objekten auslesen können. Welche Parameter für das Protokoll der Nutzerinteraktionen relevant sind hängt von dem Command ab, das die Nutzeraktionen darstellt. Herauszufinden, welches Parameter-Objekt im Zuge einer Nutzerinteraktion einzulesen ist, wird also nicht über JSON realisiert. JSON realisiert lediglich den Im- und den Export der (bekannten) Parameter-Objekte.}}\rule{0pt}{10ex}\\ [7ex] \hline
\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
\hyperlink{b}{Java 8 oder höher als Implementierungssprache} & 
\hyperlink {d}{Benutzung einer leichtgewichtigen relationalen Datenbank zum Protokollieren der Nutzerinteraktionen}\\ 
\hyperlink {h}{Hohe Qualität}&
\hyperlink {i}{Command} \\
\hyperlink {bb}{Protokoll von Nutzerinteraktionen} &
\hyperlink {mm}{Protokoll JSON} \\
\hyperlink {ww}{Softwarelizenzbudget} &
\\ \hline
\multicolumn{2}{|l|}{Lösungen} \\
\multicolumn{2}{|l|}{\parbox{16cm}{
	\textbf{\cb{\hypertarget{www}{S63 - Jackson}}}: \\
	Mit Jackson können Objekte gelesen und deren Informationen ins JSON-Format überführt werden. Dies erlaubt die Überführung von Objekten in einen strukturierten String, der zu einem späteren Zeitpunkt leicht gelesen werden kann.\\
	\textbf{S64 - GSON}: \\
	Mit GSON können Informationen aus Objekten gelesen werden und ins JSON-Format geparst werden.\\
	\textbf{S65 - JSONP}: \\
	Mit JSONP können Objekte geparst und deren Informationen ins JSON-Format geschrieben werden. \\
	} }\\ [6ex] \hline
	\multicolumn{2}{|l|}{Verwandte Strategien} \\
	\textbf{\hyperlink{jjj}{S33 - JavaScript Object Notation (.json)}}&
	\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
Wir entscheiden und für \cb{S63}, da diese API Objekte am schnellsten parsen kann und dementsprechend Informationen mit größter Geschwindigkeit ins JSON-Format überführt werden können.
\end{onehalfspace}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
	\hline
	\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{26: Dependency Injection}}} \\  \hline\hline 
	\multicolumn{2}{|l|}{\parbox{16cm}{Wir arbeiten mit mehren Leuten parallel an einer Software, für die wir einen modularen Aufbau anstreben. Dabei wäre es vorteilhaft, wenn jeder Entwickler, die Systembestandteile/Module anderer Gruppenmitglieder nutzen könnte bevor deren Implementierung abgeschlossen ist. Um uns nicht um die Übergabe beziehungsweise Weitergabe von Objekten kümmern zu müssen, können wir Dependency Injection nutzen. Damit kann man Attribute beliebiger Klassen deklarieren und auf deren Werte und Methoden zugreifen – ohne die Herkunft derselben vorab festzulegen.}}\rule{0pt}{10ex}\\ [7ex] \hline
	\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
	\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &  \hyperlink {uu}{Abgabedatum} \\
	\hyperlink {vv}{Entwickler-Fähigkeiten} &
 	\hyperlink {ww}{Softwarelizenzbudget} \\
	\hyperlink {xx}{Teamgröße} &
   \\ \hline
	\multicolumn{2}{|l|}{Lösungen} \\
	\multicolumn{2}{|l|}{\parbox{16cm}{
			\textbf{\cb{\hypertarget{guice}{S66 - Google Guice}}}: \\
	Verwendung von Google Juice für Dependency Injection-Aspekte.\\
			\textbf{S67 - Spring}: \\
	Wir könnten die Funktionalitäten im Bereich Dependency Injection von Spring nutzen.
	} }\\ [6ex] \hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
	Mit \cb{Guice} können Objekte anderer Klassen leicht in eine Klasse injiziert werden und dort Attributen zugewiesen werden. Dabei ist \cb{Guice} auch vielfältig zur Erzeugung von Objekten zur Laufzeit einsetzbar. Das Framework bietet also zahlreiche Funktionalitäten im Generischen-Bereich. Die Funktionalitäten von \cb{Guice} sind durch Annotationen leicht (mit wenig Quellcode) nutzbar. \\
	\cb{Spring} bietet auch Möglichkeiten, die wir für das Dependency Injection in unserem System nutzen können. Allerdings sind diese Funktionen nicht so leicht nutzbar. Das liegt daran, dass Springs Dependency Injection-Funktionalitäten in einem Kontext entstanden sind, in der noch nicht einmal Java 5 fertig entwickelt worden war. \\
	Wir entscheiden uns deshalb für Strategie \cb{S66 - Google Guice}, da die Verwendung der Annotationen für Dependency Injection einfacher ist, als der von \cb{Spring} verwendete Ansatz. Außerdem können wir bei Verwendung von \cb{Guice} von der Funktion der generischen Objekt-Erstellung profitieren.
\end{onehalfspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newpage
\begin{tabular} {|p{8cm} p{8cm}|}
\hline
\rowcolor{prob}\multicolumn{2}{|l|}{\parbox{16cm}{\textbf{27: Umwandlung der Graphdaten zwischen dem JUNG- und JGraphT-Format}}} \\ \hline\hline 
\multicolumn{2}{|l|}{\parbox{16cm}{Zur Auswertung des Graphen sollen zunächst die von JUNG bereitgestellten Funktionen genutzt werden. Da mit diesen nicht alle Anforderungen im Bereich der Graph-Analyse abgedeckt werden, greifen wir zur Umsetzung einiger Analyse-Funktionen auf JGraphT zurück. Das Format der Datenklassen eines Graphen, das JUNG bereitstellt, entspricht nicht dem Datenklassen-Format, das JGraphT nutzt. Aus diesem Grund ist eine Umwandlung der JUNG-Datenklassen in die von JGraphT erforderlich.}}\rule{0pt}{5ex}\\ [1ex] \hline
\multicolumn{2}{|l|}{\textbf{Einflussfaktoren}}\\
\hyperlink{b}{Java 8 oder höher als Implementierungssprache} &
\hyperlink {g}{Hohe Usability}\\
\hyperlink {h}{Hohe Qualität}&
\hyperlink {k}{JUNG} \\
\hyperlink {n}{Sphären} &
\hyperlink {p}{Typisierte Knoten} \\
\hyperlink {q}{gerichtete Kanten (3 Relationstypen} &
\hyperlink {r}{Anzahl, Größe, Position, Farbe, Beschriftung der Sphären/ Knoten/Kanten ist flexibel} \\
\hyperlink {t}{Zuordnung von Sphären und Knoten} &
\hyperlink {x}{Automatische Anordnung zur Übersichtlichkeit} \\
\hyperlink {z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} &
\hyperlink {aa}{Graph Visualisierung/ Interaktion/ Editierung}\\
\hyperlink {hh}{Sprache.Beschriftung} &
\hyperlink {oo}{Analyse des Graphen} \\
\hyperlink {pp}{Auswertung des Graphen} &
\hyperlink {qq}{Graph-Analyse mittels Graphmaße} \\ 
\hyperlink {rr}{Analyse über einen wählbaren Ausschnitt des Graphen} &
\hyperlink {ss}{Filter von Knoten und Kanten}  \\
\hline
\multicolumn{2}{|l|}{Lösungen} \\
\multicolumn{2}{|l|}{\parbox{16cm}{
\textbf{\cb{\hypertarget{umwandlungskomponente}{S68 – eigene Umwandlungskomponente}}} \\
Es wird unsererseits eine Komponente entwickelt, deren Aufgabe es ist, die Datenklassen unseres Graphen, die in JUNG vorliegen, in die Datenklassen von JGraphT umzuwandeln, sodass wir die von JGraphT zur Verfügung gestellten Funktionen zur Graph-Auswertung nutzen können.
} }\\ \hline
\multicolumn{2}{|l|}{Verwandte Strategien} \\
\textbf {\hyperlink{aadd}{S10 – Modularisierung}} &
\textbf{\hyperlink{aabb}{S15 - Modularisierung}} \\
\textbf{\hyperlink{aacc}{S18 - Modularisierung}} &
\textbf{\hyperlink{eee}{S19 - JUNG}} \\
\textbf{\hyperlink{fff}{S22 - JUNG}} &
\textbf{\hyperlink{eigeneImplementierung}{S24 - eigene Implementierung}} \\
\textbf{\hyperlink{xxx}{S25 - JGraphT}} &
\\\hline
\end{tabular}\\ \\ \\
\begin{onehalfspace}
Die Umwandlung der Datenklassen zwischen dem JUNG- und dem JGraphT-Format wird mit \cb{einer eigenen Komponente} umgesetzt. So muss auch nur diese Komponente ausgetauscht werden, wenn zu einem späteren Zeitpunkt anstelle von JGraphT ein anderes Framework verwendet werden soll, um die von JUNG bereitgestellten Analyse-Möglichkeiten zu erweitern.
\end{onehalfspace}




\newpage

\section{Konzeptionelle Sicht}
\label{sec:konzeptionell}
\emph{Autoren: Jacky Philipp Mach}\\ \\

In der folgenden Abbildung ist die konzeptionelle Sicht der Applikation mit all ihren Komponenten visualisiert, wobei auch die Zusammenhänge und Kommunikationsmechanismen dieser Komponenten dargestellt werden.\\
Die Grundstruktur unserer Architektur ist angelehnt an das Model-View-Controller-Designpattern kombiniert mit dem Command-Designpattern, wie erwähnt in den Strategien \hyperlink{bbb}{S8 - MVC} und \hyperlink{command}{S9 - Command}. \\
Dabei ist die GUI-Komponente die \textit{View}, die Command-Komponente der \textit{Controller} und die Datamodel-Komponente das \textit{Model}. \\ 

In der \texttt{GUI}-Komponente wird hauptsächlich das Visuelle unserer Applikation festgelegt. Erstgenannte wird wie in \hyperlink{kkk}{S34 - GUI Framework JavaFX} festgelegt mit JavaFX umgesetzt. 
Die \texttt{GUI}-Komponente kommuniziert daher mit der Komponente \texttt{JUNG}, wie in \hyperlink{eee}{S19 - JUNG} beschlossen wurde.
Das Anzeigen des Graphen in der \texttt{GUI} wird, wie in Strategie \hyperlink{lll}{S36 - SwingNode} besprochen, umgesetzt. \\

Über eine Control-Schnittstelle kommuniziert die \texttt{GUI}-Komponente mit der \texttt{Command}-Komponente für die Interaktion des Users mit dem Graphen. Die Commands werden also mit den GUI-Interaktionen verknüpft.
Außerdem kommuniziert die \texttt{GUI}-Komponente mit der \texttt{Datamodel}-Komponente, um das Protokoll der Nutzerinteraktion in der GUI zu visualisieren und darstellen zu können. \\

In der \texttt{Command}-Komponente befindet sich die meiste Logik unserer Applikation. Sie dient als Schnittstelle zwischen allen internen Modulen und ist daher mit allen Hauptkomponenten über eine Control-Schnittstelle verbunden. Zusätzlich besitzt \texttt{Command} auch die Undo-/Redo-Funktionalität. Um die Editierung und Interaktion mit dem Graphen zu ermöglichen, wird über eine Control-Schnittstelle die \texttt{JUNG}-Komponente angesprochen. \\

Die {JUNG}-Komponente beinhaltet alle nötigen Klassen, die für das Rendern, das Filtern und die Visualisierung des Graphen zuständig sind sowie die Funktionalität des Graphen implementieren. Da die auszuführenden Aktionen bei Maus- und Tastatur-Interaktion festgelegt werden müssen, stellt die Komponente hierfür ebenfalls Klassen bereit. Außerdem enthält sie alle Datenklassen, die für die Graph-Visualisierung benötigt werden. \\

Die Art und Weise, wie die Speicherung der Protokolldaten von statten geht, wird in der \texttt{Datamodel}-Komponente festgelegt. Das Datenmodell besteht aus Logs (Protokolle der Nutzerinteraktion), das wir nutzen um Nutzerinteraktion zu speichern, umgesetzt nach der gewählten Strategie in \hyperlink{aaa}{S7 - Datenmodell}. \\
Auch befindet sich dort die Logik zum Speichern des Graphen (\hyperlink{yy}{S1 - GXL}). Die benötigten Informationen fürs Speichern der Nutzerinteraktion und des Graphen bekommt die \texttt{Datamodel}-Komponente über eine data-Schnittstelle von der \texttt{Command}-Komponente. \\
Auch dient die Datamodel-Komponente als Schnittstelle zwischen der Datenbank und den anderen Komponenten, die Informationen aus der Datenbank benötigen, wie zum Beispiel die \texttt{GUI}-Komponente fürs Anzeigen des Protokolls der Nutzerinteraktion.\\
Da es erforderlich ist die Objekte des Nutzerprotokolls und den Graphen in einer Datenbank zu speichern, werden die Objekte über eine data-Schnittstelle an die \texttt{Persistence}-Komponente weitergeleitet, um die Informationen weiterzuverarbeiten und anschließend in der Datenbank zu speichern. \\ 

Die \texttt{Persistence}-Komponente wird gemäß der Strategie \hyperlink{rrr}{S50 - Hibernate} realisiert.
Hibernate gibt die verarbeiteten Informationen über eine data-Schnittstelle weiter an die \texttt{H2 Database}, die anschließend die Daten speichert. Die \texttt{Database}-Komponente wird realisiert mit einer H2 Datenbank, wie in der Strategie \hyperlink{ppp}{S45 - H2 Database} beschrieben.\\ 

Die \texttt{Handler}-Komponente legt fest, wie die Dateiformate PDF, GXL und OOF mit Hilfe der \texttt{GXL}-, \texttt{Freeheb}- und \texttt{Jackson}-Komponente exportiert und importiert werden. \\
Die \texttt{GXL}-Komponente stammt von der Bibliothek \textit{SourceForge} und hilft beim Lesen und Erstellen der GXL-Dateien (\hyperlink{ttt}{S56 - Sourceforge Framework}). \\
Gemäß der Strategie \hyperlink{jjj}{S33 - JavaScript Object Notation (.json)} wird der Ex- und Import von Nutzerinteraktionen in der Komponente \texttt{Handler} mit Hilfe der \texttt{Jackson}-Komponente umgesetzt. Die \texttt{Jackson}-Komponente dient als Schnittstelle für das JSON-Format und unterstützt das System dabei, die Parameter zu importieren und zu exportieren(\hyperlink{www}{S63 - Jackson}).\\
Auch legt die \texttt{Handler}-Komponente fest, wie die Strategie \hyperlink{ooo}{S43 - Eigener Datentyp} umgesetzt wird und nimmt dabei die \texttt{Jackson}- und die \texttt{GXL}-Komponente zu Hilfe. \\
Für die Strategie \hyperlink{hhh}{S29 - java.awt.Graphics2D} besitzt das System die Komponente\\ \texttt{FreeHEB Vectorgraphics} um java.awt.Graphics2D als zahlreiche Formate (z.B. SVG, PDF) zu exportieren, wie erwähnt in \hyperlink{iii}{S30 - Freeheb Vectorgraphics}. Dafür benötigen wir von der \texttt{JUNG}-Komponente nur die Darstellung des Graphen, welches über eine data-Schnittstelle übermittelt wird. Die Grafik wird der \texttt{Handler}-Komponente übergeben und diese setzt das Drucken(\hyperlink{ggg}{S26 - Java API}) und Exportieren der PDF um. \\ 

Um den Graphen auszuwerten, benutzt das System Algorithmen, die bereits von \texttt{JUNG} angeboten werden.(\hyperlink{fff}{S22 - JUNG}). Da diese Komponente jedoch nicht den benötigten Funktionsumfang deckt, haben wir in unsere Applikation auch die \texttt{JGraphT}-Komponente eingebaut, gemäß der beschriebenen Strategie  \hyperlink{xxx}{S25 - JGraphT}. Dafür wird die Struktur des Graphen in der \texttt{JGraphT Handler}-Komponente nach Strategie \hyperlink{umwandlungskomponente}{S68 – eigene Umwandlungskomponente} übersetzt, sodass JGraphT die Informationen zum Berechnen der Graph-Eigenschaften nutzen kann. \\ 

Die \texttt{Logger}-Komponente ist in unsere Applikation eingebaut, um uns bei der Entwicklung und dem Debuggen zu unterstützen, indem sie die Applikation während der Laufzeit durch Logging aufzeichnet und uns zum Beispiel hilft Fehlerzustände oder das Verhalten der Applikation besser zu verstehen und nachzuvollziehen.\\ \\
\newpage
\includepdf[pages=-, landscape, scale=0.77,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{Konteptionelle Sicht},\pagestyle{fancy}}]{KonzeptionelleSicht.pdf}


\newpage
\section{Datensicht}
\label{sec:datensicht}

\emph{Autoren: Anthony Mendil, Clement Phung, Bastian Rexhäuser}\\ \\

Im folgenden beschreiben wir die Datensicht unseres Systems. Bei Erläuterungen zu dieser beziehen wir uns auf folgende Strategien: \hyperlink{yy}{Strategie S1 - GXL}, \hyperlink{aaa}{Strategie S7 - Datenmodell}, \hyperlink{eee}{Strategie S19 - JUNG}, \hyperlink{jjj}{Strategie 33 - JavaScript Object Notation (.json)} und \hyperlink{ooo}{Strategie S43 - Eigener Datentyp} sowie auf die \hyperlink{ppp}{Strategie S45 - H2 Database}. Außerdem werden wir Bezug zu den Strategien \hyperlink{rrr}{Strategie S50 - Hibernate}, \hyperlink{ttt}{Strategie S56 - GXL-Framework (bei Source Forge gehostet)} und \hyperlink{vvv}{Strategie S61 - Regeln in der GXL-Datei} nehmen.\\

Es sei an dieser Stelle explizit angemerkt, dass wir für die Repräsentation des Graphen kein komplett eigenes Datenmodell erstellen. Stattdessen verwenden wir das vom Framework JUNG vorgegebene Datenmodell mit unseren eigenen Datenklassen \texttt{Vertex} (für Knoten) und \texttt{Edge} (für Kanten) (\hyperlink{eee}{Strategie S19 - JUNG}). \\
Die \texttt{Vertex}-Klasse hat neben den naheliegenden Attributen auch noch weitere Attribute, welche jede zuführenden Pfeilspitze mit einem \texttt{ScopePoint} in eine \texttt{Map} speichert. Ein Element der Aufzählung \texttt{ScopePoint} stellt das Quartal eines Knoten dar, in welches eine Pfeilspitze auf ein Knoten andockt. Pfeilspitzen von Kanten, welche in das selbe Quartal führen und den gleichen Pfeilspitzen-Typ haben, werden in der Visualisierung zusammengefasst dargestellt. \\

Da in unserem Fall Sphären benötigt werden, erstellen wir eine Klasse \texttt{Sphere} (für Sphären) und erweitern mit ihr das vorgegebene Datenmodell (genauer gesagt erweitert unsere Klasse SydromGraph die Klasse DirectedSparseGraph von JUNG). 
Für die Speicherung des Graphen sowie von allen nötigen Informationen existiert die Klasse \texttt{Syndrom}. Sie fasst den Graphen, die optionalen Vorgaben/Bearbeitungsregeln (\texttt{Template}), sowie die zum Rendern und zur Visualisierung benötigten Komponenten von JUNG zusammen. \\

Die soeben erwähnte \texttt{Template}-Klasse ermöglicht es ein Maximum an Sphären, Knoten (im Graphen insgesamt), Knoten in einer Sphäre und Kanten festzulegen. Des weiteren können Objekte des Graphen bestimmt werden, von denen bestimmte Eigenschaften nicht verändert werden dürfen, sowie die Arten der erlaubten Kanten eingeschränkt werden.\\

Die Klasse \texttt{Values} enthält einige Werte, die beim Erzeugen eines neuen Graph-Objekts (Vertex, Edge, Sphere) benötigt werden. \texttt{Values} ist eine Singleton-Klasse, damit alle Klassen des Systems, die die Werte aus \texttt{Values} benötigen, auf die gleichen Wertebelegungen zugreifen können. Die Nutzerinteraktion in der GUI beeinflussen die Werte, die in \texttt{Values} gesetzt sind. Stellt der Nutzer beispielsweise die Standardfarbe für neue Symptome um, so wird der entsprechende Wert in der Klasse \texttt{Values} angepasst, sodass neu erzeugte Symptome diese Farbe haben.\\

Um die Persistenz von Daten zu gewährleisten, verwenden wir die eingebettete Datenbank H2 Database in unserem System (\hyperlink{ppp}{Strategie S45 - H2}). Bei der Kommunikation mit der Datenbank wird das Framework Hibernate genutzt, welches es unter Verwendung von JPA ermöglicht, Objekte (als Instanzen von Klassen) unseres Systems in eine relationale Datenbank zu persistieren (\hyperlink{rrr}{Strategie S50 - Hibernate}). Hierbei findet ORM (Object-Relational Mapping) Anwendung. \\ 

Um den Graphen zu speichern bietet sich die GXL-Repräsentation aus den in der Entscheidung für \hyperlink{yy}{S1 - GXL} genannten Gründen an. Ein als Text-Repräsentation vorliegender Graph wird dabei mit einer Identifikationsnummer versehen und in einer Tabelle unserer Datenbank persistiert. Die Realisierung der genannten Konstruktion lässt sich in der zugehörigen Mapping-Klasse \texttt{Graph} wiederfinden.  An dieser Stelle ist anzumerken, dass wir uns dafür entschieden haben, in der Datenbank immer höchstens einen Graphen zu speichern. Die Tabelle mit den Graphen hat dementsprechend maximal einen Eintrag. Immer wenn versucht wird, einen neuen Graphen zu erstellen oder einen alten zu importieren, wird der Nutzer gefragt, ob er seinen aktuellen Graphen (inklusive festgehaltenem Nutzerverhalten) vorher exportieren möchte, da die Datenbank beim Import (und dem Neuerstellen eines Graphen) geleert wird.\\
Die Übersetzung unseres Graphen in das GXL-Format erfolgt unter Nutzung des bei Sourceforge gehosteten GXL-Frameworks (\hyperlink{ttt}{Strategie S56 - GXL-Framework}). Falls der Benutzer eine Vorlage erstellt, werden auch die darin für die Diagramm-Erstellung im \hyperlink{``Diagramm bearbeiten''-Modus}{``Diagramm bearbeiten''-Modus} gesetzten Einschränkungen in selbiger GXL festgehalten (\hyperlink{vvv}{Strategie S61 - Regeln in der GXL-Datei}).\\ 

Die Nutzerinteraktionen mit dem Graphen werden, wie auch der Graph selbst, in der embedded H2 Database gespeichert. Für die Nutzerinteraktionen existiert eine eigene Tabelle in der Datenbank sowie eine zugehörige Mapping-Klasse \texttt{Log}, welche für jeden Eintrag die relevanten Informationen enthält (\hyperlink{aaa}{Strategie S7 - Datenmodell}). Zu diesen Informationen gehört auch ein Text im JSON-Format, der aus dem jeweiligen Parameterobjekt erzeugt wird (\hyperlink{jjj}{Strategie 33 - JavaScript Object Notation (.json)}). Es sei explizit erwähnt, dass zu einem Log ein Graph gehört, der Graph dennoch nichts vom Log weiß und von diesem auch keine Informationen lesen kann (Many to One Beziehung). \\
Die bereits erwähnten Parameterklassen sind Unterklassen der Klasse \texttt{Param}. Jede dieser Parameter-Klassen gehört speziell zu einer Aktion, für die sie die nötigen Informationen enthält. Hinzufügende und entfernende Aktionen gleicher Art sowie aktivierende und deaktivierende gleicher Art benutzen die gleichen Parameter-Klassen. Beispielsweise haben demnach die Aktionen des Hinzufügens und Entfernens mehrerer Kanten beide ein \texttt{AddRemoveVerticesParam}. Je nach Aktion werden diese Informationen bei der Ausführung unterschiedlich verwendet. Es ist ebenso anzumerken, dass die einzelnen Parameter-Klassen im Diagramm individuell Assoziationen zu den Klassen \texttt{Vertex}, \texttt{Edge} und \texttt{Sphere} hätten, je nachdem welche Attribute sie besitzen. Um Übersichtlichkeit zu bewahren haben wir im Diagramm nicht alle Parameter-Klassen mit ihren zugehörigen Attributen dargestellt, sondern exemplarisch vier solcher Klassen ausgewählt. Alle Parameter-Klassen lassen sich im Package \texttt{log\_management.parameters} finden. \\

In unserem Programm ist ebenfalls das Exportieren einzelner Graphen mit den zugehörigen Log-Einträgen möglich. Dies geschieht anhand eines selbst entwickelten Dateiformates (OOF für \glqq out of frameworks\grqq; \hyperlink{ooo}{Strategie S43 - eigener Datentyp}). \\

\textit{Anmerkungen zu dem Diagramm}: \\
Alle dargestellten Attribute sind \texttt{private}, es existieren aber Getter und Setter für die Attribute. Deswegen sind die Attribute im Diagramm alle als \texttt{public} markiert. \\
Des weiteren lassen sich die Rollennamen direkt aus den Klassennamen herleiten, weshalb wir sie im Diagramm nicht explizit nennen. Die Assoziation zwischen \texttt{Vertex} und \texttt{ScopePoint} betreffend, wurde beschlossen, dass \texttt{Vertex} statt einem Attribut, in welchem die verschiedenen \texttt{ScopePoints} für die jeweils gleichen Arten der Relationstypen zusammengefasst werden, drei Attribute gegeben werden, die jeweils ausschließlich gleichartige \texttt{ScopePoints} eines Pfeiltyps beinhalten. Diese Unterteilung sorgt für eine klare logische Trennung und ermöglicht es ohne Filterung direkt auf die \texttt{ScopePoints} zuzugreifen, die einem Pfeiltyp entsprechen. Es muss also nicht erst die Liste aller \texttt{ScopePoints} nach der Art der Relation gefiltert werden.\\

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\pagestyle{fancy},\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{data model}}]{Datenmodell_SWP2019.pdf}


\newpage
\section{Modulsicht}
\emph{Autoren: Anthony Mendil, Bastian Rexhäuser, Clement Phung, Jacky Philipp Mach, Jonah Jaeger, Nina Unterberg}\\\\

Im folgenden ist der statische Aufbau unseres Systems in Form der Modulsicht zu finden. In dieser werden besonders wichtige oder für eine Gruppe von Modulen stellvertretend stehende Module unseres Systems genannt. Dabei wird auf die Funktion und Notwendigkeit dieser Module eingegangen sowie teilweise deren grundlegender Aufbau thematisiert. Außerdem wird in diesem Kapitel beschrieben wie die Module zusammenwirken, um die geforderten Anforderungen zu erfüllen. Bei Ausführungen zur Bedeutung, zum Aufbau und zum Zusammenwirken von Modulen wird Bezug zu den Strategien genommen, für die wir uns im Rahmen der Problemkarten im Kapitel \glqq Globalen Analyse\grqq{} entschieden haben. \\ \\

\newpage

\subsection{Übersicht}
Dieser Abschnitt beschäftigt sich mit einer Übersicht über alle Module des gesamten Projektes. \\
Diese Module und deren Abhängigkeiten untereinander sind auf der folgenden Seite als Paketdiagramm dargestellt.
Im Allgemeinen ist die Struktur des Projektes angelehnt an das Model-View-Controller-Designpattern, gemäß der Strategie Model-View-Controller (\glqq\hyperlink{bbb}{S8}\grqq{} und \glqq\hyperlink{modelviewcontroller}{S13}\grqq). Dabei setzt das Package \texttt{gui} die View um, \texttt{log\_management} die Model-Komponente und \texttt{actions} die Controller-Komponente. \\

Das Package \texttt{actions} beinhaltet \texttt{Action}-Klassen, von denen die meisten Aktionen auf dem Graphen umsetzen. Die \texttt{Action}-Klassen werden dabei durch Interaktionen des Nutzers mit der grafischen Benutzeroberfläche (z.B. durch das Klicken auf einen Button) aufgerufen. Dem entsprechend importiert das Package \texttt{gui} das Package \texttt{actions}. \\

Das Modul \texttt{gui} beinhaltet alle Klassen, die zur Erstellung und Interaktion mit der Benutzeroberfläche benötigt werden. Das \texttt{gui}-Modul ist mit dem Modul \texttt{actions} verbunden, da die GUI Nutzerinteraktionen entgegennimmt und diese zur Ausführung an das Package \texttt{actions} weiterleitet. Im Modus \glqq Vorlage bearbeiten\grqq{} und \glqq Diagramm bearbeiten\grqq{} sowie im \glqq Analyse\grqq-Modus werden Informationen über den Graphen visualisiert, weshalb ebenfalls eine Abhängigkeit zwischen \texttt{gui} und dem Package \texttt{graph} besteht. Die GUI bezieht sich außerdem auf das Modul \texttt{log\_management}, da erstgenannte im \glqq Analyse\grqq{}-Modus Informationen über das Protokoll der Nutzerinteraktionen visualisiert. \\

Das Persistieren der Daten wird im Package \texttt{log\_management} umgesetzt. Dieses Package ist in drei weitere Packages unterteilt: \texttt{dao}, \texttt{parameters} und \texttt{tables}. \texttt{dao} \glqq Data Acess Object\grqq{} bildet die Benutzerschnittstelle, die es anderen Modulen ermöglicht, auf die Daten in der Datenbank zuzugreifen. Das Package \texttt{parameters} beinhaltet \texttt{Param}-Klassen. Jeder \texttt{Action}-Klasse ist eine \texttt{Param}-Klasse zugeordnet. Diese wird bei der Persistierung der \texttt{Actions} als \texttt{Log} in einen JSON-String umgewandelt und als Attribut eines \texttt{Log}-Objektes abgespeichert und in die Datenbank geschrieben. \texttt{tables} beinhaltet die Klassen, welche den Aufbau eines \texttt{Graph}- und den eines \texttt{Log}-Objektes beschreiben. Diese Objekte werden mit \hyperlink{rrr}{S50 - Hibernate} beziehungsweise JPA persistiert und gemäß \hyperlink{ppp}{S 45} in einer embedded H2 Datenbank abgespeichert. \\ 

Alle Import- und Export-Aktionen werden im Package \texttt{io} implementiert. \texttt{io} benötigt die Protokoll-Daten, welche durch das Package \texttt{dao} zugänglich sind. Außerdem greift \texttt{io} auf Klassen aus \texttt{graph} zu, da dort die Klassen liegen, welche die Daten zu dem aktuellen Syndrom / Graphen beinhalten. \\

Das Package \texttt{jgrapht} setzt die Funktionalität um, einen Graphen aus unserem System in einen Graphen umzuwandeln, der vom Framework \hyperlink{xxx}{jgrapht} erkannt wird (siehe Strategie \hyperlink{umwandlungskomponente}{S68 – eigene Umwandlungskomponente}). Deswegen besteht eine Abhängigkeit zwischen den Packages \texttt{jgrapht} und \texttt{graph.graph}. \\

Alle Klassen, die Funktionalität für den programminternen Graphen umsetzen, sind im Package \texttt{graph} implementiert. Dieses Package ist in drei Packages unterteilt: \texttt{algorithm}, \texttt{graph} und \texttt{visualization}. \texttt{algoithm} beinhaltet Klassen, die unseren Graphen nach bestimmten Bedingungen / Algorithmen filtern. \texttt{graph} beinhaltet alle Datenklassen zu dem Graphen und Funktionalitäten, die benötigt werden, um den Graphen umzusetzen. \texttt{visualization} stellt Klassen zur Verfügung, die die visuellen Eigenschaften des Graphen bestimmen und diese darstellen. \\

Mit der eben beschriebenen Aufteilung des Systems in Module folgen wir der Strategie Modularisierung (siehe \hyperlink{aadd}{S10}, \hyperlink{aabb}{S15}, \hyperlink{aacc}{S18} und \hyperlink{aaaa}{S49}. Außerdem haben wir mit Umsetzung dieser Strategie eher die Möglichkeit, Arbeitspakete mit einem sinnvollen Arbeitsaufwand zu definieren, was der Strategie \hyperlink{zeitmanagement}{S14 - Zeitmanagement} dient. \\

An dieser Stelle wollen wir auf die Schnittstellenbeschreibung verweisen, da nach der Erklärung der Grundstruktur unseres Systems (die in diesem Unterkapitel erfolgt ist) die Verständlichkeit der und die Einarbeitung in die Schnittstellenbeschreibung leichter fallen sollte. Bei Betrachtung unserer Schnittstellenbeschreibung ist bereits zu sehen, dass wir unsere Programmbestandteile dokumentiert haben. Bei der Implementierung werden wir gemäß Strategie \hyperlink{aaad}{S17 - Dokumentierung von geschriebenem Code} an diesem Prinzip festhalten. \\

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\pagestyle{fancy},\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{package diagram}}]{package.pdf}

\textit{Anmerkung}:
Die folgenden Klassendiagramme sollen das Zusammenspiel der einzelnen Klassen und Module untereinander bestmöglich darstellen. \\
Der Übersichtlichkeit halber wurden diese in einzelne Diagramme unterteilt. Ein Diagramm eines Moduls zeigt die Beziehung der Klassen innerhalb des Moduls und die ausgehenden Abhängigkeiten zu den anderen Packages. \\
Die \texttt{Getter} und \texttt{Setter} werden nicht in den Diagrammen dargestellt. Wir verwenden im Projekt die Java-Bibliothek Lombock. Diese erzeugt \texttt{Getter} und \texttt{Setter} zur Kompilierzeit, wenn die Attribute entsprechend annotiert sind. Deswegen kann bei den Attributen der Klassen im Allgemeinen davon ausgegangen werden, dass sie über eine \texttt{Getter}- und \texttt{Setter}-Methode verfügen.\\

\subsection{\texttt{io}}
Der Graph soll gemäß Strategie \hyperlink{yy}{S1 – GXL} \glqq plain\grqq{} als String in der Datenbank abgespeichert werden. Dieser String beinhaltet eine GXL (Graph eXchange Language) –Repräsentation des Graphen.\\
Daher muss es ein Modul geben, welches alle Informationen des in der GUI angezeigten Graphen abfragt und diesen in ein GXL-Format transferiert. Analog dazu muss die Möglichkeit bestehen, aus einem GXL-String die \texttt{Syndrom}-Instanz beziehungsweise Graph-Repräsentation zu generieren, die dann als aktueller Graph im Programm angezeigt wird.\\ 

Außerdem soll das Programm die Möglichkeit bieten, eine GXL-Datei zu importieren/exportieren. Diese Funktionalität muss gemäß Einflussfaktor \hyperlink{ii}{GXL- Export und -Import} bereit gestellt werden.\\ 
Für die Umsetzung dieser Funktionen haben wir im \texttt{io}-Package die Klasse \texttt{GXLio} implementiert. \\

In der Klasse \texttt{GXLio} sind dementsprechend io-Methoden für die GXL-Repräsentation des Graphen zu finden, welche (neben dem Dateinamen beim Export) beide den Pfad der zu importierenden Datei beziehungsweise den Pfad für die zu exportierende Datei übergeben bekommen (\texttt{importGXL(), exportGXL()}). \\
Um die Funktion vollständig zu realisieren sind außerdem je eine Methode zum Schreiben der GXL-Daten in die \texttt{Syndrom}-Instanz (\texttt{gxlToInstance()}) sowie zur Erstellung einer GXL-Repräsentation aus der Instanz (\texttt{gxlFromInstance()}) vorgesehen. \\
Zweitere Methode ist außerdem für die genannte GXL-Speicherung in der Datenbank nützlich, da sie genau die benötigte GXL-Variante des Graphen bereitstellt. An dieser Stelle kann also die Funktionalität einer Methode zur Realisierung verschiedener Anforderungen genutzt werden, wie wir es in Strategie \hyperlink{aaab}{S48 - Wiederverwendung von System-eigenen Komponenten} vorgesehen haben. Dieses Vorgehen spart Zeit, sodass wir es auch mit Blick auf Strategie \hyperlink{zeitmanagement}{S14 - Zeitmanagement} anwenden sollten. \\ 

Über die injizierten Instanzen der \texttt{Syndrom}- und \texttt{GraphDao}-Klasse, erhalten die Objekte der \texttt{GXLio}-Klasse alle Informationen zu dem in der GUI visualisierten Graphen. Das Injizieren ist mittels Dependency Injection und gemäß Strategie \hyperlink{guice}{S66 - Google Guice} über das Framework Guice umgesetzt. \\
Um diese Informationen in das GXL-Format zu überführen, wird im Zuge der Implementierung das bei SourceForge gehostete GXL-Framework verwendet (siehe Strategie \hyperlink{ttt}{S56 Sourceforge Framework}). Die Arbeit mit diesem Framework bietet sich nicht nur an, da es hilfreiche Funktionalität zur Realisierung des Im- und Exports bereitstellt, sondern auch weil es eine leicht verständliche, gut dokumentierte API bereitstellt (siehe Strategien \hyperlink{aaaf}{S12} und \hyperlink{ddd}{S16}). Daneben greift die Verwendung der Bibliotheken, die von dem bei SourceForge gehosteten GXL-Framework bereitgestellt werden, die Strategie (System-) Bibliotheken auf (siehe \hyperlink{ccc}{S11} und \hyperlink{qqq}{S47}). \\

Durch das \texttt{Template}-Attribut in der \texttt{Syndrom}-Klasse haben Methoden, welche eine GXL-Repräsentation eines Graphen erstellen, aus einem \texttt{Syndrom}-Objekt auch Zugriff auf die Bearbeitungsregeln, denn diese werden in einem Objekt der \texttt{Template}-Klasse hinterlegt.
Durch diesen Ansatz können die Bearbeitungsregeln in einer GXL-Repräsentation gespeichert werden, gemäß der Strategie \hyperlink{vvv}{S61 - Regeln in der GXL-Datei}. \\ 

Da wir nicht nur den Graphen isoliert als GXL-Datei exportieren, sondern ihn auch zusammen mit den Nutzerinteraktionen als OOF-Repräsentation bereitstellen wollen, haben wir die Klasse \texttt{OOFio} hinzugefügt. Diese ist ebenfalls im \texttt{io}-Package zu finden. Mit dieser wollen wir die gemeinsame Speicherung der Nutzerinteraktionen mit einem (als GXL-Repräsentation vorliegenden) Graphen realisieren (Strategie \hyperlink{ooo}{S43 - Eigener Datentyp}). \\

Um diesen gemeinsamen Datentyp zu erzeugen, gibt es die Methode \texttt{createOOF()}, die eine GXL-Repräsentation eines Graphen und Nutzerinteraktionen als JSON erhält, wobei diese beiden Parameter je als String übergeben werden. Diese Methode wird benötigt, um die übergebenen Werte zusammenzuführen und zu exportieren. \\
(\texttt{exportOOF()}) speichert die zusammengeführten Informationen als Datei eines eigenen Datentyps (im \texttt{.oof}-Format), an dem Pfad und mit dem Namen der Datei, den die Methode übergeben bekommt. \\

Diese Datei muss jedoch auch wieder geöffnet werden können. Dies geschieht durch die Methode \texttt{importOOF()}. Diese bekommt den Pfad der zu importierenden Datei als String und schreibt die Daten in die Datenbank (Protokoll) und in die Instanz (Graph). Dabei benutzt sie die Methoden \texttt{gxlFromOOF()} und \texttt{jsonFromOOF()}, welche jeweils die OOF-Datei als String bekommen und die jeweiligen Datenteile zurückgeben. \\
Da die \texttt{OOFio}-Klasse zur Erstellung einer OOF-Datei ein GXL-String benötigt, wird ein Objekt vom Typ \texttt{GXLio} erstellt und auf diesem die Methode \texttt{gxlFromInstance()} aufgerufen.\\ 

Damit die Klasse die genannten Funktionalitäten umsetzen kann, bekommt sie das \texttt{LogDao}- und das \texttt{GraphDao}-Objekt injiziert. 

Mit den Methoden der \texttt{PDFio}-Klasse aus dem \texttt{io}-Package sind unter Einsatz der Frameworks beziehungsweise APIs der PDF-Druck (gemäß Strategie \hyperlink{ggg}{S26 - Java API}) und der PDF-Export (gemäß Strategie \hyperlink{iii}{S30 - Freeheb Vectorgraphics}) realisierbar. \\
Der Aufruf zum Drucken geschieht durch \texttt{printPDF()}, während der Export als PDF in \texttt{exportPDF()} implementiert wird. Für diese Methoden ist die Methode zur PDF-Erstellung (gemäß Strategie \hyperlink{hhh}{S29 - java.awt.Graphics2D} nützlich. Diese ist als \texttt{createPDF()} implementiert und gibt die PDF als Datenstrom wieder. \\
\texttt{PDFio} bekommt im \texttt{constructur} den \texttt{VisualizationViewer} des angezeigten Graphen übergeben, um die PDF zu erstellen. \\

Im folgenden ist eine Abbildung zum \texttt{io}-Package zu sehen, in dem auch seine eben beschriebenen Abhängigkeiten zu den Packages \texttt{dao} und \texttt{graph.graph} dargestellt sind. \\ Von den Funktionen des Im- und Exports, die in gewisser Weise Schnittstellen unserer Anwendung zu außerhalb letztgenannter liegender Bereiche darstellen, kommen wir im nächsten Abschnitt zum programminternen Aussehen unserer Benutzeroberfläche. Damit ist der Übergang zu den Aspekten, die ausschließlich unser System betreffen, geschaffen.

\newpage
\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{io class diagram},\pagestyle{fancy}}]{io.pdf}


\subsection{\texttt{gui}}
Die Benutzeroberfläche wurde mit JavaFX (siehe Strategie \hyperlink{kkk}{S34 - GUI Framework JavaFX}) und mit Hilfe der Anwendung SceneBuilder von Gluon (gemäß Strategie \hyperlink{mmm}{S38 - Scene-Builder}) umgesetzt. Die erstellte GUI ist in der Applikation als FXML-Datei gespeichert und wird beim Starten unserer Applikation in der \texttt{Main}-Klasse geladen. Letztgenannte ist außerdem für das Starten der gesamten Anwendung zuständig. \\

Um die GUI mit der gewünschten Funktionalität der Applikation zu verbinden, existiert die Klasse \texttt{Controller}. Sie dient als Schnittstelle zwischen der GUI und den internen Modulen. \\
FXML ist sehr gut geeignet, um die Darstellung der GUI-Elemente zu definieren und die Methoden in \texttt{Controller} jeweils zu den Elementen zuzuordnen. Diese Methoden werden beim Interagieren mit den GUI-Elementen aufgerufen und müssen in der \texttt{Controller}-Klasse angegeben werden. Da einige GUI-Elemente mehr Funktionalität benötigen als nur einen Methodenaufruf beim Interagieren, werden diese Elemente nochmals in der \texttt{Controller}-Klasse referenziert, um sie zu erweitern.\\

Die \texttt{Controller}-Klasse besitzt außerdem die internen Klassen \texttt{ColorPickerHandler} und \\ \texttt{MenuItemHandler}. Diese werden benötigt, da die \texttt{GUI}-Elemente \texttt{MenuItem} und \texttt{ColorPicker} zusätzlich an die aufgerufene Methode übergeben müssen, welchen Wert der User ausgewählt hat, beispielsweise die gewählte Farbe. \\
Diese Werte werden zusätzlich in dem Singleton-Objekt der Klasse \texttt{Values} den zugehörigen Attributen zugewiesen, damit die \texttt{Actions}-Objekte und das \texttt{Syndrom}-Objekt auf diese Werte zugreifen können. \\

Zur Graph-Visualisierung wird das Framework \hyperlink{eee}{JUNG} verwendet (siehe Strategie \hyperlink{eee}{S19 - JUNG}). Da dieses Framework auf Swing basiert, wird die Swing-Komponente in die mit JavaFX erstellte GUI durch eine Swing-Node eingebunden. Dieses Vorgehen folgt Strategie \hyperlink{lll}{S36 - SwingNode}.\\

Da die \texttt{GUI} den Graphen außerdem in der Seitenleiste in textueller, strukturierter Form darstellen soll, benötigt die GUI Informationen über die Komponenten des Graphen. Die Information sind über das \texttt{Syndrom}-Objekt aus dem Package \texttt{graph.graph} zugänglich. \\

Das Objekt der Klasse \texttt{ActionHistory} aus dem Package \texttt{actions} wird benötigt, um die Actions (gemäß Strategie \hyperlink{command}{S9 - Command}) mit den Interaktionen des Nutzers zu verknüpfen. Diese führt zuvor erstellte Actions aus. Außerdem kann so die benötigte \texttt{redo}- und \texttt{undo}-Funktionalität umgesetzt werden. \\

Das Interface \texttt{ObserverSyndrom} aus dem Package \texttt{actions} wird implementiert, um die GUI nach Veränderungen des Graphen upzudaten.\\

Um das Anzeigen des Protokolls der Nutzerinteraktion zu ermöglichen, bekommt die \texttt{Controller}-Klasse das Benutzerprotokoll über ein Objekt der \texttt{LogDao}-Klasse aus dem Package \texttt{dao}. Dieses bildet die Schnittstelle zur Datenbank. \\

Die Klasse \texttt{LoadLanguage} besitzt noch weitere GUI-Elemente zusätzlich zu den bereits referenzierten in der \texttt{Controller}-Klasse, um die Texte der \texttt{GUI} bei Bedarf auf eine andere \hyperlink{hh}{Sprache} umzustellen. \\
	
Die GUI (deren Aufbau und Abhängigkeiten durch das folgende UML-Diagramm visualisiert werden) ermöglicht es dem Benutzer, die Funktionen unseres Systems zu nutzen. Die Interaktion des Nutzers mit der GUI führt programmintern (wie eben beschrieben) zum Aufruf bestimmter \texttt{Action}-Objekte, welche im Package \texttt{actions} eingeordnet sind. Dieses Package wird im nächsten Abschnitt genauer beschrieben.


\newpage
\includepdf[pages=-, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{gui class diagram},\pagestyle{fancy}}]{gui.pdf}



\subsection{\texttt{actions}}
Das Package \texttt{actions} repräsentiert die Controller-Komponente des Model-View-Controller-Patterns, welches wir gemäß \hyperlink{bbb}{S8} beziehungsweise \hyperlink{modelviewcontroller}{S13} umsetzen. \\ 
Diese Controller-Komponente ist nach dem \texttt{Command}-Pattern nach \hyperlink{zz}{S4} beziehungsweise \hyperlink{command}{S9} aufgebaut. \\

Die abstrakte Klasse \texttt{Action} stellt die Oberklasse dar. Diese implementiert zwei abstrakte Methoden \texttt{undo} / \texttt{redo}. Eine weitere abstrakte Klasse \texttt{GraphAction} erweitert die \texttt{Action}-Klasse. Jeder \texttt{GraphAction} wird ein \texttt{Syndrom} injiziert. Durch dieses \texttt{Syndrom}-Objekt verfügt jede \texttt{GraphAction} über die benötigten Informationen zu dem visualisierten Graphen. Da \texttt{Syndrom} ein Singleton ist, verfügt nach einer Änderung des Graphen das ganze System darüber und kann das aktuelle \texttt{Syndrom} entsprechend visualisieren.  Dies ist erforderlich, damit sich die vom Nutzer durchgeführten Aktionen auch auf den gerade in Bearbeitung befindlichen Graphen auswirken.\\ 
Eine weitere abstrakte Klasse setzt die benötigte Funktionalität für eine \texttt{LogAction}. Zudem haben alle \texttt{LogActions} eine Verbindung zu \texttt{LogEntryName} und zu \texttt{Param}. Dies ist beides für die Persistierung von Bedeutung. Die Verbindung zu \texttt{Param} bedeutet, dass zu jeder \texttt{LogAction} ein Objekt einer konkreten Unterklasse der abstrakten Oberklasse \texttt{Param} gehört. \\
Diese Parameter-Objekte werden erzeugt, wenn eine Aktion ausgeführt wird und beinhalten die Parameterdaten der Action. So ist es möglich, zu jedem Zeitpunkt die genauen Daten aller \texttt{LogActions} auszulesen (da diese ja in die Datenbank persistiert werden). Dies hilft bei der Umsetzung der \texttt{undo}- und \texttt{redo}-Funktion. Die Actions sind unsere Umsetzung der Strategie \hyperlink{command}{S9 - Command}  \\


Wie man aufgrund der Existenz der Klasse \texttt{SwitchModiEditorAction} im \texttt{actions.other}-Package bereits erahnen kann, wird auch das Umschalten zwischen den Funktionsmodi über eine Action realisiert. Der aktuelle Funktionsmodus wird dabei in der Klasse \texttt{Values} im Package \texttt{gui} gespeichert.  Die Funktionsmodi, die in unserer Anwendung existieren, sind in der Enum \texttt{FunctionMode} im \texttt{graph.graph}-Package zu finden. Die beschriebene Umsetzung folgt der Strategie \hyperlink{uuu}{S59 - Modi als eigener Teil unserer Applikation}.
\texttt{AnalysesGraphAction} steht mit \texttt{AnalyseTypeSingle} und mit \texttt{AnalyseTypeSeveral} aus dem Package \texttt{graph.algorithmen} in Abhängigkeit, um den oder die ausgewählten Filteroptionen ausmachen zu können, die von der Analyse betroffen sein sollen. \\

An die eben erfolgte Beschreibung des Aufbaus des Packages \texttt{actions} und den Ausführungen zu dessen Abhängigkeiten (siehe auch folgendes UML-Diagramm) schließt sich eine Übersicht über alle Actions im nächsten Abschnitt an.

\includepdf[pages=-, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{actions class diagram},\pagestyle{fancy}}]{actions.pdf}

Eine Übersicht über alle \texttt{Action}-Packages, die der Übersicht halber auf der vorherigen Abbildung nicht komplett dargestellt werden konnten, ist auf der folgenden Abbildung zu sehen. \\

Um die Lücke zwischen der Übersicht über alle Actions und den Abhängigkeiten des \texttt{action}-Packages mit anderen Modulen zur (für die Auswertung der Nutzerinteraktionen erforderlichen) Persistierung zu schließen, wird im folgenden Abschnitt auf das \texttt{log\_management}-Package genauer eingegangen. Dadurch können die genannte Lücke geschlossen und weitere Aspekte unserer Anwendung erklärt werden. 

\includepdf[pages=-, scale=0.84,landscape,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{actions overview class diagram},\pagestyle{fancy}}]{actionsOverview.pdf}


\subsection{\texttt{log\_management}}

Die Umsetzung der Strategie \hyperlink{aaa}{S7 - Datenmodell} ist in der Klasse \texttt{Log} im Package \texttt{log\_management.tables} zu sehen. Im Package \texttt{log\_management} werden neben der Speicherung der Nutzerinteraktionen in Form der Logs die weiteren Aspekte der Persistierung umgesetzt. \\
Die Daten-Persistierung setzen wir mit Hilfe von \hyperlink{rrr}{S50 - Hibernate} um. Die im Package \texttt{tables} liegenden Klassen stellen die Objekte dar, die wir in der Datenbank persistieren wollen. 



Dabei sind die \texttt{Log}-Objekte wie beschrieben zur Speicherung der Nutzerinteraktionen erforderlich, während die \texttt{Graph}-Objekte (wie in Strategie \hyperlink{yy}{S1 - GXL} vorgesehen) eine Graphrepräsentation beinhalten. \\

Die \texttt{Log}-Objekte besitzen unter anderem ein Attribut \texttt{parameters}. Dieses Attribut repräsentiert ein zugehöriges \texttt{Param}-Objekt als String. Die \texttt{Param}-Objekte beinhalten alle wichtigen Informationen zu der zugehörigen Aktion, damit diese verständlich für den Benutzer rekonstruiert werden kann. Dieser String wird durch eine Konvertierung eines \texttt{Param}-Objektes zu einem \texttt{JSON}-String erzeugt. Die \texttt{JSON}-Umwandlung erfolgt gemäß Strategie \hyperlink{www}{S63 - Jackson} mit Jackson. \\

Die \texttt{Graph}-Objekte haben ein Attribut \texttt{gxl}, welches den visualisierten Graphen als GXL-Repräsentation gemäß \hyperlink{yy}{S1 - GXL} beinhaltet. Der GXL-String wird durch das \texttt{io}-Package realisiert, weshalb hier auch eine Abhängigkeit besteht.\\

Die Existenz des Packages \texttt{parameters} sorgt dafür, dass die Nutzerinteraktionen in den Logs beschrieben werden können. Daneben gehört zu jedem \texttt{Log}-Eintrag unter anderem ein \texttt{Graph} und ein \texttt{LogEntryName} wie im Klassendiagramm dargestellt. Letzterer ist im Package \texttt{actions} realisiert. \\

In selbigem Package findet sich auch das Interface \texttt{ObserverSyndrom}, das in Form der Klasse\\ \texttt{DatabaseManager} im Package \texttt{log\_management} implementiert wird. \\
Der DatabaseManager steht außerdem in Abhängigkeit zu dem \texttt{io}-Package, da der DatabaseManager das Graph-Objekt erstellt, welches den Graphen in der Datenbank repräsentieren soll. Dieser enthält die aktuelle Graph-Repräsentation als String. \\
Der DatabaseManager kommuniziert mit dem \texttt{LogDao} und dem \texttt{GraphDao}, die jeweils das \texttt{Dao}-Interface implementieren. Dabei werden dem \texttt{GrapDao} Graphen und dem \texttt{LogDao} Logs zugewiesen. Durch diesen Aufbau können die Änderungen, die ein Nutzer an einem Graphen vornimmt, als CRUD-Operationen (Create, Read, Update, Delete) erfasst und (wenn erforderlich) in der Datenbank persistiert werden. \\ 

Wir verwenden eine embedded H2 Datenbank und Hibernate für die Kommunikation zwischen unserer Anwendung und der genannten Datenbank (wie im \texttt{persistence.xml}-File im Package\\ \texttt{resources.META-INF.resources} zu sehen ist - siehe Schnittstellenbeschreibung; ist nicht im Diagramm dargestellt). Damit folgen wir den Strategien \hyperlink{ppp}{S45 - H2 Database} und \hyperlink{rrr}{S50 - Hibernate}. \\

Nachdem nun das Package \texttt{log\_management} und seine Abhängigkeiten beschrieben wurden, zu dem im folgenden noch ein UML-Diagramm zu finden ist, wird im nächsten Abschnitt genauer auf die \texttt{Param}-Klassen eingegangen.

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{log\_management class diagram},\pagestyle{fancy}}]{log_management.pdf}



Die \texttt{Param}-Klassen finden sich im Package \texttt{log\_management.parameters}. 
Die Klassen haben individuelle Verbindungen zu Teilen des \texttt{graph.graph}-Packages. So ist beispielsweise die \texttt{EditFontSphereParam} mit \texttt{Sphere}, die \texttt{AddRemoveAnchorPointsParam} mit \texttt{Edge}, die \texttt{EditEdgesTypePram} mit \texttt{EdgeArrowType} und die \texttt{EditVerticesSizeParam} mit \texttt{Vertex} verbunden. \\
Die Klassen innerhalb des Pakets \texttt{graph.graph} sind auf geeignete Weise miteinander verknüpft (siehe folgendes Unterkapitel). \\ 
Da das Klassendiagramm durch die zahlreichen Abhängigkeiten der Parameterklassen zu Klassen aus dem Package \texttt{graph.graph} zu unübersichtlich wurde, sind diese Klassen ohne Assoziationen im Package \texttt{graph.graph} dargestellt. Die Abhängigkeiten zwischen den Patameter-Klassen und Klassen aus \texttt{graph.graph} ergeben sich implizit aus der Benennung der \texttt{Param}-Klassen. Beispielsweise ist die Klasse \texttt{EditFontSizeVerticesParam} mit der \texttt{Vertex}-Klasse über eine einfache, von der \texttt{Param}-Klasse ausgehende Assoziation verbunden. \\

Die \texttt{Param}-Klassen werden benötigt, um die wichtigen Informationen von einer zugehörigen Aktion zu erfassen und in der Datenbank abzuspeichern, damit diese bei Bedarf an den Benutzer übermittelt werden können. Wie genau diese persistiert werden, ist im vorangehenden Unterkapitel beschrieben.\\

Wie eben angedeutet wird im folgenden Abschnitt auf das Package \texttt{graph.graph} genauer eingegangen. Da hier die Datenklassen unseres Graphen thematisiert werden, ist dieser Abschnitt an den vorangehenden angeschlossen. Schließlich wurden in diesem auch unsere in der Datenbank zu persistierenden, eigenen Datenklassen genannt. Letztere und die anderen Aspekte des Packages \texttt{log\_management} sind in folgendem Diagramm dargestellt:

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{parameters class diagram},\pagestyle{fancy}}]{param.pdf}




\newpage

\subsection{\texttt{graph.graph}}

Das Package \texttt{graph.graph} beinhaltet die Datenklassen des Graphen und Klassen, die sich auf die Funktionalität des Graphen beziehen. \\

Die Klasse \texttt{Syndrom} führt alle Komponenten des Frameworks JUNG (Strategie \hyperlink{eee}{S19} beziehungsweise \hyperlink{fff}{S22}) zusammen und ist ein \textit{Singleton}, da dieses Objekt global im ganzen Projekt verfügbar sein muss. \\
Unsere Datenklassen zu dem Graphen erweitern das Datenmodell von JUNG. Klassen, die erweiterte Funktionalität des Graphen implementieren, erweitern meistens Klassen aus JUNG oder orientieren sich an dessen Klassen. \\

\textit{Syndrom} enthält ein \texttt{SyndromGraph}-Objekt, ein \texttt{StaticLayout}-Objekt und ein \texttt{VisualisationViewer}-Objekt, welche die grundlegenden Informationen über den Graphen beinhalten, beispielsweise Listen von \texttt{Vertex}, \texttt{Edge} und \texttt{Sphere}. Die \texttt{Transformer}-Attribute von \texttt{Syndrom} werden aus dem Package \texttt{graph.visualization} importiert und sind vor allem für die Visualisierung von Bedeutung. Die \texttt{Predicate}-Attribute von \texttt{Syndrom} werden aus dem Package \texttt{graph.alogorithmen} importiert und werden später für die Filterung und Umsetzung von Algorithmen auf den Graphen benötigt. \\

Die Klassen \texttt{VisualisationViewer} und \texttt{StaticLayout} haben wir komplett von JUNG übernommen, wir weisen den generischen Typen der Klassen unsere \texttt{Vertex}- / \texttt{Edge}-Objekte zu. Somit sind unsere eigenen Datenklassen nicht  komplett von dem JUNG-Framework unabhängig.\\

Das \texttt{SatelliteVisualisationViewer}-Objekt, das \texttt{ViewGrid}- und das \texttt{GraphZoomScrollPane}-Objekt sind JUNG zugehörige Klassen, die wir benötigen, um \hyperlink{dd}{Zoom} und \hyperlink{ff}{Zoom.Kontext} umzusetzen. Die Klasse \texttt{ViewGrid} werden wir selber implementieren, die Implementierung ist aber an JUNG-Klassen angelehnt.\\

Das Attribut \texttt{pluggable} der Klasse \texttt{PluggableGraphMouse} wird ebenfalls von JUNG zur Verfügung gestellt. Diese Klasse besitzt Funktionalität, um \texttt{GraphMousePlugins} (im Package \texttt{visualization}) hinzuzufügen und zu entfernen. Diese besitzen Methoden, um MouseEvents auf dem \texttt{VisualisationViewer} zu erkennen und entsprechend Funktionalität umzusetzen. \\

Die Klasse \texttt{Syndrom} enthält außerdem ein Attribut \texttt{values}, welches eine Instanz der Klasse \texttt{Values} ist. Die \texttt{GUI} schreibt gesetzte Werte der GUI in die Klasse, z.B. den derzeit gewählten \texttt{EdgeType}. Syndrom benötigt diese Werte, damit Objekte entsprechend dieser Werte erstellt werden können. \\



Nachdem wir nun das Package \texttt{graph.graph} erklärt haben (zudem nachfolgende Graphik gehört), gehen wir im nächsten Abschnitt auf das \texttt{graph.visualization}-Package ein, sodass der Bogen von der Benutzeroberfläche über die auf letztgenannter aufgerufenen Nutzerinteraktionen (Actions) und über die Persistierung letztgenannter sowie über die Datenklassen des Graphen sich zu einem Kreis schließt. Denn in diesem \texttt{visualization}-Package werden die Aspekte der Visualisierung des Graphen umgesetzt. Ein visualisierter Graph ist wiederum zentraler Bestandteil der Benutzeroberfläche, bei der der Bogen begonnen hat.



\newpage

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{graph.graph class diagram},\pagestyle{fancy}}]{graph_graph.pdf}


\subsection{\texttt{graph.visualization}}

Das Package \texttt{visualization} beinhaltet alle Klassen, die auf die Visualisierung des Graphen Einfluss haben. \\

Ein großes Teilpaket von \texttt{visualization} sind die Transformer.  Alle diese Klassen implementieren ein Interface \texttt{Transformer}. Die Transformer wandeln ein Eingabe-Objekt in ein Ausgabe-Objekt um. Das Eingabe-Objekt bleibt dabei unverändert. Wir beziehungsweise das Framework JUNG verwendet Transformer größtenteils dazu, um Daten aus Objekten zu extrahieren, beispielsweise die Farbe eines \texttt{Vertex}. \\

Ein weiteres Teilpaket ist \texttt{control}. Die Klassen aus dem Package erben alle von der Klasse \\ \texttt{GraphMousePlugin} aus JUNG. Diese Plugins implementieren die Funktionalität, die bestimmt, welche Anweisungen bei z.B. einem Klick auf einem \texttt{VisualisationViewer} ausgeführt werden sollen. \\

\texttt{renderers} beinhaltet eine zentrale Klasse \texttt{SyndromRenderer}, die den \texttt{BasicRenderer} von JUNG erweitert. Diese Klasse wird aufgerufen, wenn der Graph gerendert und auf den \texttt{VisualisationViewer} gezeichnet werden soll. Zusätzlich überschreiben wir die Implementierung von \texttt{BasicEdgeRenderer} und erstellen eine weitere Klasse \texttt{SphereRenderer}, um z.B. das \hyperlink{cc}{Zusammenfassen von Pfeilspitzen} zu ermöglichen. \\

Die Klasse \texttt{SyndromPickSupport} überschreibt ebenfalls eine Klasse aus JUNG: \texttt{ShapePicksupport}. Diese erweitern wir mit der Funktionalität ebenfalls \texttt{Sphere}-Objekt auswählen zu können. \\ 

Das Package \texttt{util} beinhaltet zur Zeit nur eine Klasse, und zwar die Klasse \texttt{SyndromArrowFactory}, welche Shape-Objekte generiert, die unsere Pfeilspitzen für Kanten bilden. \\

\texttt{graph.visualization} importiert Klassen aus dem Package \texttt{graph.graph}, da die Klassen die Objekte, welche sie visualisieren sollen, benötigen. \\

Die folgende Graphik ist eine Visualisierung des \texttt{graph.graph}-Packages und der im vorangehenden beschriebenen Zusammenhänge dieses Packages mit anderen Modulen. Der nächste Abschnitt beschreibt das Package \texttt{graph.algorithmen}, welches der Auswertung eines visualisierten Graphen dient.

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{graph.visualization class diagram},\pagestyle{fancy}}]{visualization.pdf}

\subsection{\texttt{graph.algorithmen}}
Den größten Teil des Packages \texttt{algorithmen} nimmt das Package \texttt{predicates} ein. Alle Klassen in \texttt{predicates} implementieren das Interface \texttt{Predicate}. Dieses bietet eine Funktionsschnittstelle, die einen Vergleichstest für ein Objekt ausführt. Es wird entweder \texttt{true} oder \texttt{false} zurückgeben, je nachdem, ob das Objekt den Test besteht oder nicht. JUNG verwendet diese Schnittstelle zur \hyperlink{ss}{Filterung} des Graphen. Nach Strategie \hyperlink{eigeneImplementierung}{S24 - eigene Implementierung} implementieren wir alle Algorithmen, die zur Analyse / Auswertung des Graphen benötigt werden, unter Zuhilfenahme der von JUNG und JGraphT zur Verfügung gestellten Funktionen und Algorithmen (siehe Strategien \hyperlink{fff}{S22  - JUNG} und \hyperlink{xxx}{S25 - JGraphT} selbst.\\

Zusätzlich gibt es nur drei \textit{Enum}-Klassen. Diese verwenden wir um zu differenzieren, welche Filterung des Graphen durchgeführt werden soll. Bei einer Filterung auf Grundlage \texttt{AnalyseTypeSeveral}-Enumerationskonstanten, können mehrere kombiniert werden, sodass eine kombinierte Filterung ausgeführt wird. Bei \texttt{AnalyseTypeSingle}-Enumerationskonstanten immer nur genau eine. \texttt{SelectionType} beschreibt die verschiedenen Selektionsarten. \\

Außerdem haben wir das Package \texttt{graph.algorithmen} so strukturiert, dass eine übersichtliche Darstellung des Graphen gemäß der Strategien \hyperlink{sss}{S53 - Layouts in Layouts}, \hyperlink{xee}{S54 - JUNG Layouts} und \hyperlink{xff}{S55 - Eigenes Layout} bereitgestellt werden kann. \\

\texttt{algorithmen} importiert Klassen des Packages \texttt{graph}, da bei einer Filterung die Klasse natürlich Zugriff auf die Objekte benötigt, die gefiltert werden sollen.\\

In der folgenden Abbildung ist das Package \texttt{graph.algorithmen} mit seinen Abhängigkeiten dargestellt. Da wir thematisch bei Auswertung sind, folgt im nächsten Abschnitt eine Beschreibung des Moduls \texttt{jgrapht}.

\includepdf[pages=-, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{graph.algorithmen class diagram},\pagestyle{fancy}}]{graph_algorithmen.pdf}



\subsection{\texttt{jgrapht}}
In unserem Programm soll neben dem Editieren des Graphen auch das Auswerten des Graphen von großer Bedeutung sein. Für das Auswerten des Graphen müssen bestimmte Algorithmen zur Verfügung stehen. Bei den meisten Anforderungen im Bereich Graph-Analyse handelt es sich um optionale Anforderungen aus dem Chinese Menue. Mit der Umsetzung dieser Funktionalitäten realisieren wir die Strategie \hypertarget{nnn}{S40 - erweiterte Anforderungen}. Diese Anforderungen sind O«Analyse» (siehe Einflussfaktor \hyperlink {oo}{Analyse des Graphen}), O«Auswertung» (siehe Einflussfaktor \hyperlink {pp}{Auswertung des Graphen}), O«Auswertung.Graphmaße» (siehe Einflussfaktor \hyperlink {qq}{Graph-Analyse mittels Graphmaße}) und O«Ausschnitt» (siehe Einflussfaktor \hyperlink {rr}{Analyse über einen wählbaren Ausschnitt des Graphen}). \\ Manche für die Umsetzung dieser Anforderungen erforderlichen Algorithmen (z.B. Zyklensuche im Graphen) werden nicht von JUNG bereitgestellt, sind allerdings von JGraphT bereits umgesetzt und können nach Strategie \hyperlink{xxx}{S25 - JGraphT} von dem JGraphT-Framework übernommen werden. Die Nutzung der Algorithmen lässt sich in dem Package \texttt{JGraphT} wiederfinden.\\
Da aber unser Datenmodell des Graphen nicht mit dem kompatibel ist, welches JGraphT benutzt, muss der Graph zuerst in das andere Modell übersetzt werden. Die Methode \texttt{convertGraphToJGraphT} realisiert diese Funktion (gemäß Strategie \hyperlink{umwandlungskomponente}{S68 – eigene Umwandlungskomponente}). Die Ergebnismenge der Algorithmen wird als \texttt{Set<Vertex>} oder \texttt{List<Vertex>} zurückgegeben, wobei die Klasse \texttt{Vertex} der Klasse \texttt{Vertex} unseres ursprünglichen Modells entspricht. \\ 

Nachdem wir nun auf alle Module unserer Anwendung eingegangen sind (zu dem eben thematisierten Package \texttt{jgrapht} ist folgend ebenfalls eine visualisierende Graphik vorhanden), beschreiben wir im letzten Abschnitt dieses Kapitels noch den Zusammenhang zwischen der Modulsicht und der konzeptionellen Sicht.

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{jgrapht class diagram},\pagestyle{fancy}}]{jgrapht.pdf}


\subsection{Zusammenhang zwischen Modulsicht und konzeptioneller Sicht} Wie im Abschnitt zur GUI-Komponente  in der konzeptionellen Sicht und eben unter Bezugnahme auf verwendete Strategien erwähnt, wird die GUI mit JavaFX umgesetzt. Der Bezug zur JUNG-Komponente besteht in der Einbettung derselben über Swing-Nodes. Die Aufteilung des übergeordneten Packages \texttt{graph} in die untergeordneten Packages \texttt{graph}, \texttt{visualization} und \texttt{algorithmen} ist an die konzeptionelle Sicht angelehnt. Dort wurde beschrieben, dass JUNG für verschiedene Aspekte wie die Visualisierung und das Rendern Klassen bereithält. Darüber hinaus existiert die Komponente JGraphT, die wir (neben JUNG) für die Auswertung des Graphen nutzen wollen und die im Package \texttt{jgrapht} umgesetzt werden wird. Die Command-Komponente entspricht dem \texttt{actions}-Package. Bei der Umsetzung der Undo-/Redo-Funktionalität, deren Existenz in der konzeptionellen Sicht bereits angedeutet wurde, wird die Klasse \texttt{ActionHistory} im Package \texttt{actions} eine wichtige Funktion übernehmen. Die Kommunikation von Commands und der GXL-Komponente (die Logik letzterer wird in der GXLio-Klasse umgesetzt werden) wurde in der konzeptionellen Sicht beschrieben. Das Model-View-Controller Design-Pattern wurde bereits in der konzeptionellen Sicht erwähnt und dessen Umsetzung in unserer Anwendung wurde an mehreren Stellen in der Modulsicht genauer erklärt. Unsere Datenklassen haben wir im Package \texttt{log\_management} umgesetzt. Die Komponenten PDF und FreeHeb VectorGraphics finden sich im \texttt{io}-Package in der Klasse \texttt{PDFio} wieder. Die JGraphT-Komponente findet sich im Package \texttt{jgrapht} wieder.



\newpage
\section{Ausführungssicht}
\label{sec:ausfuehrung}
\emph{Autoren: Bastian Rexhäuser, Clement Phung, Jacky Philipp Mach, Jonah Jaeger}\\ \\

In der folgenden Abbildung ist unsere Ausführungssicht zu erkennen. Da der Aufbau unserer Software dem einer lokalen Anwendung entspricht, wird es pro Nutzer genau eine Instanz der Anwendung geben. Die zeitgleiche Ausführung mehrerer Instanzen unserer Anwendung ist nicht vorgesehen. \\

Zum Starten und Beenden der Anwendung ist das Modul \texttt{gui} zuständig. Es arbeitet mit dem Modul \texttt{actions} zusammen, indem Bestandteile aus \texttt{gui} (z.B. Buttons oder Menü-Elemente der JavaFX-Oberfläche (nach \hyperlink{kkk}{Strategie S34})) bestimmte Actions aus dem Modul \texttt{actions} aufrufen. Der Aufruf der Actions über die GUI ist nach dem Entwurfsmuster Command (\hyperlink{command}{Strategie S9}) umgesetzt. Durch diese Aufrufe kommt es zu Veränderungen des dargestellten Graphen im Modul \texttt{graph}. Der geänderte Graph und der Log-Eintrag, der die Action beschreibt und mit einer eigenen Datenklasse gemäß Strategie \hyperlink{aaa}{S7 - Datenmodell} umgesetzt wird, werden in der Datenbank gespeichert. Dafür arbeitet das Modul \texttt{log\_management} mit dem Subsystem \texttt{Persistence} zusammen, um das zweite Subsystem \texttt{H2DB} (\hyperlink{ppp}{Strategie S45 - H2 Database}) anzusteuern. Letzteres ist nur der Fall, falls die ausgeführte Action eine \texttt{LogAction} ist. Bei diesen Actions handelt es sich um für die Protokollierung des Nutzerverhaltens relevante Actions.\\
Im selben Prozess werden Import und Export durch das Modul \texttt{io} geregelt. Diese Funktionen werden ebenfalls durch Action-Objekte aus \texttt{actions} ausgelöst (nach deren Aufruf durch Elemente aus \texttt{gui}). \\
Zum Auswerten der Graph-Eigenschaften wird in einigen Fällen das Modul \texttt{jgrapht} (\hyperlink{xxx}{Strategie S25 - JgraphT}) benötigt und in anderen Funktionen des Frameworks JUNG (\hyperlink{fff}{S22 - JUNG}). Auch diese Funktionen werden von Actions ausgelöst.\\

Die Realisierung unserer Anwendung erfolgt durch mehrere Threads. Sowohl die GUI als auch die SwingNodes des Frameworks JUNG werden je auf einem eigenen Thread laufen (siehe folgende Abbildung: Ausführungssicht). Somit wird für eine durchgehend ansprechbare und dadurch angenehmer bedienbare Benutzeroberfläche, gemäß \hyperlink{g}{Hoher Usability}, gesorgt.\\


\begin{figure}[ht]
	\begin{center}
		\includegraphics[width=0.8\textwidth]{Ausfuehrungssicht.png}
		\caption{Ausführungssicht}
	\end{center}
\end{figure}
\clearpage
\newpage

\newpage
\section[Zusammenhänge zwischen Anwendungsfällen und Architektur]{Zusammenhänge zwischen Anwendungsfällen und Architektur\sectionmark{Zusammenhänge AF u. Architektur}}
\sectionmark{Zusammenhänge AF u. Architektur}
\label{sec:anwendungsfaelle}
\emph{Autoren: Clement Phung, Anthony Mendil, Jacky Philipp Mach, Jonah Jaeger, Nina Unterberg}\\ \\

\subsection{Anwendungsfall: Ein Lehrer erstellt ein Syndrom}

\begin{tabular} {|p{16cm}|}
	\hline
	\rowcolor{anw}\parbox{16cm}{\textbf{A1: Ersteller erstellt Syndrom}} \\\hline
	\hline
	\textbf{Akteure}: Ersteller
	\\\hline
	\textbf{Vorbedingungen}: Das Programm ist geöffnet. Der Ersteller hat schon vorher mit dem Programm gearbeitet. \\ Der Ersteller drückt auf den Menüpunkt \textit{Datei}  $\rightarrow$ \textit{Neuen Graph erstellen}. Das System öffnet zwei Pop-Up-Fenster (Abfrage für Speichern des alten Graphen und Eingabefeld des Namen des neuen Graphen) \\
	\textit{Ziel}: Ein neues Syndrom erstellen.
	\\\hline
		\textbf{Regulärer Ablauf}: \begin{itemize}
		\itemsep-0.5em
		\item der Ersteller gibt den Namen des Graphen an und klickt \textit{Ok}
	\end{itemize}
	\\\hline
	\textbf{Varianten}: Der Ersteller könnte Elemente zu dem neu erstelltem Graphen hinzufügen und diese miteinander verknüpfen.
	\\\hline
	\textbf{Nachbedingung}: Der Ersteller hat einen Graphen erstellt. Diesen kann der Ersteller nun beliebig bearbeiten und speichern/exportieren.
	\\\hline
	\textbf{Fehler-/Ausnahmefälle}:  Der Ersteller könnte vergessen den alten Graphen zu speichern, sodass beim Erstellen des neuen Graphen der alte Graph überschrieben wird.
	\\\hline
\end{tabular}
\\ \\ \\
Der eben beschriebene Anwendungsfall ist im folgenden Sequenzdiagramm dargestellt. \\
Da als Vorbedingung angegeben war, dass der Benutzer bereits mit dem Programm gearbeitet hat, sind alle Singleton-Klassen bereits initialisiert und im Projekt verfügbar. \\
Im Laufe des Sequenzdiagramms wird eine \texttt{CreateGraphAction} erzeugt, die bei Ausführung das im Programm aktuelle \texttt{Syndrom}-Objekt mit einem neuen Graphen / Layout belegt. Folgend werden die \texttt{GUI} und der \texttt{DatabaseManager} \textit{benachrichtigt}, dass ein neuer Graph erstellt wurde. \\
Im Methodenaufruf des \texttt{DatabaseManagers} wird die Graph-Tabelle unserer Datenbank geleert, da unser Programm intern immer nur eine Graph-Repräsentation speichert. \\
Danach wird ein neuer Graph erstellt und das Syndrom-Objekt als GXL-String in der Graph-Tabelle gespeichert. 

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{1. Sequenzdiagramm},\pagestyle{fancy}}]{first_.pdf}


\subsection{Anwendungsfall: Ein Lehrer fügt eine Sphäre hinzu}

\begin{tabular} {|p{16cm}|}
	\hline
	\rowcolor{anw}\parbox{16cm}{\textbf{A2: Bearbeiter fügt eine Sphäre hinzu}} \\\hline
	\hline
	\textbf{Akteure}: Bearbeiter
	\\\hline
	\textbf{Vorbedingungen}: Das Programm ist geöffnet, eine GXL-Datei wurde schon erfolgreich importiert. Die Arbeitsfläche ist leer. \\
	\textit{Ziel}: Eine Sphäre hinzufügen.
	\\\hline
		\textbf{Regulärer Ablauf}: \begin{itemize}
		\itemsep-0.5em
		\item der Bearbeiter klickt auf den \textit{Sphäre hinzufügen}-Button
		\item der Bearbeiter klickt in die Arbeitsfläche 
	\end{itemize}
	\\\hline
	\textbf{Varianten}: Der Bearbeiter könnte der Sphäre eine Bezeichnung geben oder mehrere Sphären zu dem Graphen hinzufügen.
	\\\hline
	\textbf{Nachbedingung}: Der Bearbeiter hat eine Sphäre hinzugefügt. Danach kann der Bearbeiter weitere Elemente hinzufügen oder den Graphen exportieren.
	\\\hline
	\textbf{Fehler-/Ausnahmefälle}:  Der Bearbeiter könnte die Sphäre an eine ungünstige Stelle setzen $\rightarrow$ Der Bearbeiter kann mithilfe des \textit{Sphäre löschen}-Buttons die Sphäre löschen und mit dem \textit{Sphäre hinzufügen}-Button neu setzen. 
	\\\hline
\end{tabular}
\\ \\ \\

Da zuvor schon Aktion ausgeführt worden sind, sind alle Singleton-Objekte bereits initialisiert. \\
Der eben beschriebene Anwendungsfall ist im folgenden Sequenzdiagramm dargestellt. \\
Zu Beginn klickt der Bearbeiter den Button, um eine Sphäre hinzuzufügen. Die \texttt{GUI} schreibt daraufhin den \texttt{GraphButtonTyp} in \texttt{Values}, damit das \texttt{PickingGraphMouseEditSyndromPlugin} weiß, welche Aktion bei Klick in den \texttt{VisualisationViewer} ausgeführt werden soll. \\
Klickt der Bearbeiter nun in die SwingNode, also den  \texttt{VisualisationViewer}, wird die Aktion\\ \texttt{AddSpereLogAction} erstellt und durch die \texttt{ActionHistory} ausgeführt. \\
Bei der Ausführung der Aktion wird das neue \texttt{Sphere}-Objekt erstellt und dem Graphen hinzugefügt. \\
Außerdem wird ein \texttt{AddRemoveSphereParam}-Objekt erzeugt, welches die eben erstelle \texttt{Sphere} übergeben bekommt. \\
Folgend wird der \texttt{DatabaseManager} und die \texttt{GUI} benachrichtigt, dass sich der Graph verändert hat. \\
Der \texttt{DatabaseManager} updated die Graph-Repräsentation in der Datenbank, indem ein neuer GXL-String des Graphen erzeugt und abgespeichert wird.\\
Die \texttt{AddSpereLogAction} wird außerdem als \texttt{Log}-Objekt in der Datenbank persistiert, um das Nutzerinteraktionsprotokoll aktuell zu halten. \\
Hierzu werden dem \texttt{LogDao} das \texttt{Log}-Objekt und seine Parameter übergeben. Die Parameter werden durch Jackson zu einem JSON-String konvertiert und das \texttt{Log}-Objekt wird in der Datenbank durch Hibernate abgespeichert.


\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{2. Sequenzdiagramm},\pagestyle{fancy}}]{second.pdf}







\newpage

\subsection{Anwendungsfall: Ein/e Schüler/in arbeitet mit einer Vorlage}

\begin{tabular} {|p{16cm}|}
	\hline
	\rowcolor{anw}\parbox{16cm}{\textbf{A3: Bearbeiter modifiziert Vorlage}} \\\hline
	\hline
	\textbf{Akteure}:  Bearbeiter
	\\\hline
	\textbf{Vorbedingungen}: Das Programm ist geöffnet, die Vorlage in Form einer GXL-Datei ist schon importiert. Diese enthält eine Sphäre.\\ 
	\textit{Ziel}: Vorlage modifizieren und als neuen Datentyp speichern.
	\\\hline
	\textbf{Regulärer Ablauf}:
\begin{itemize}
	\itemsep-0.5em
	\item der Bearbeiter klickt auf den Menüpunkt \textit{Knoten hinzufügen}
	\item der Bearbeiter klickt auf die Sphäre
	\item der Bearbeiter wählt \textit{Datei} $\rightarrow$ \textit{Exportieren als} $\rightarrow$ \textit{OOF}
	\item der Bearbeiter gibt einen Speicherpfad an und drück den Button \textit{exportieren}
\end{itemize}
	\\\hline
	\textbf{Varianten}: Der Bearbeiter kann mit vielen Werkzeugen den Graph nach seinen/ihren Wünschen bearbeiten.  
	\\\hline
	\textbf{Nachbedingung}: Die Vorlage wurde modifiziert und als \textit{.oof}-Datei gespeichert. Der Bearbeiter könnte nun in den Analyse-Modus wechseln und dort den Graphen auswerten.
	\\\hline
	\textbf{Fehler-/Ausnahmefälle mit deren Nachbedingung}: Der Bearbeiter vergisst die Datei zu exportieren oder gar zu speichern $\rightarrow$ Beim erneuten Start kann er die Vorlage neu importieren und neu beginnen.
	\\\hline
\end{tabular}\\ \\ \\

Auch hier sind wie im Anwendungsfall oben alle Singleton-Objekte schon initialisiert. Zu Beginn des Anwendungsfalls klickt der Bearbeiter auf den Button \texttt{Knoten hinzufügen}. Die Benutzeroberfläche reagiert darauf mit dem Schreiben des \texttt{GraphButtonTyp} in \texttt{Values}, um dem \\\texttt{PickingGraphMouseEditSyndromPlugin} zu signalisieren, was bei einem Klick auf den \\\texttt{VisualisationViewer} passiert.\\
Die Aktion \texttt{AddVerticesLogAction} wird erstellt und, wie bei allen anderen Actions auch, von der \texttt{ActionHistory} ausgeführt. Durch die \texttt{GraphObjectFactory} wird der Knoten erstellt und dem Graphen hinzugefügt. Während der Action wird das Parameterobjekt \texttt{AddVerticesParam} erstellt und an die Action abgegeben.\\  
Da sich der Graph verändert hat, müssen wie im oberen Fall auch der \texttt{DatabaseManager} und die Benutzeroberfläche benachrichtigt werden. Nach jeder Action, also auch nach dieser, wird der Graph neu als GXL-String in die Datenbank persistiert. Auch muss für die Protokollierung des Nutzerverhaltens eine neue \texttt{Log} erstellt und in die Datenbank persistiert werden. Dem \texttt{LogDao} werden wieder die Log und die Parameter übergeben. Die Parameter werden zu einem JSON-String konvertiert und mit dem Log mithilfe von Hibernate in die Datenbank gespeichert.\\
Nun besteht noch die Action, bei dem ein Benutzer den bestehenden Graphen als OOF exportiert. Bei dem Klick auf den Button \textit{Exportieren als} $\rightarrow$ \textit{OOF}, öffnet die \texttt{GUI} ein Dialogfenster, bei dem der Nutzer einen validen Pfad eingeben und mit dem Button \textit{Exportieren} seine Ausführungsabsicht bestätigen muss. Die neue Action \texttt{exportOofAction} wird erstellt und wieder durch die \texttt{ActionHistory} ausgeführt. Ein neues Objekt der Klasse \texttt{OOFIo} wird erstellt. Von dem Objekt wird eine neue \texttt{GXLIo} kreiert, welche den Graphen als GXL-String zurückliefert. Die \texttt{Log}-Einträge werden von dem \texttt{LogDao} und die Parameterobjekte von dem bestehenden \texttt{ObjectMapper} in Strings umgewandelt. In der \texttt{OOFIo} werden dann alle Strings mit der Methode \texttt{createOOf()} zu dem neuen Datentyp fusioniert und abgespeichert.  


\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{3. Sequenzdiagramm},\pagestyle{fancy}}]{third.pdf}

\newpage

\subsection{Anwendungsfall: Schüler korrigiert Graph mit falschen Relationen}

\begin{tabular} {|p{16cm}|}
	\hline
	\rowcolor{anw}\parbox{16cm}{\textbf{A4: Bearbeiter korrigiert Syndrom}} \\\hline
	\hline
	\textbf{Akteure}:  Bearbeiter
	\\\hline
	\textbf{Vorbedingungen}: Das Programm ist geöffnet. Die GXL-Datei ist erfolgreich importiert. Diese enthält genügend Sphären und Knoten, die miteinander verknüpft sind.\\ 
	\textit{Ziel}: Syndrom modifizieren.
	\\\hline
	\textbf{Regulärer Ablauf}:
\begin{itemize}
	\itemsep-0.5em
	\item der Bearbeiter markiert eine Kante
	\item der Bearbeiter klickt auf den Menüpunkt \textit{Relationstyp ändern} $\rightarrow$ \textit{Ungewiss}
	\item der Bearbeiter klickt auf den Menüpunkt \textit{undo}
\end{itemize}
	\\\hline
	\textbf{Varianten}: Der Bearbeiter hat eine große Auswahl an Werkzeugen z.B. \textit{Sphärenfarbe ändern} oder \textit, um den Graph zu modifizieren. 
	\\\hline
	\textbf{Nachbedingung}: Der Graph wurde durch den Bearbeiter modifiziert. Danach könnte der Bearbeiter dies nun als Vorlage speichern oder den neuen Graphen nach Kriterien auswerten.
	\\\hline
	\textbf{Fehler-/Ausnahmefälle mit deren Nachbedingung}: Der Auswerter könnte mehrere Knoten auf nicht erlaubte Positionen verschieben. Das System gibt dann eine Warnmeldung aus und untersagt die Aktion.
	\\\hline
\end{tabular}\\ \\ \\

Das Diagramm für diesen Anwendungsfall erstreckt sich über zwei Seiten. Aus Gründen der Übersichtlichkeit wurden die Objekte, die auf der zweiten Seite nicht mehr verwendet werden, auf der zweiten Seite nicht mehr aufgelistet. Während das Klicken des Bearbeiters auf eine Kante und die Änderung ihres Relationstyps auf der ersten Seite modelliert wird, wird die Aktion auf der zweiten Seite wieder rückgängig gemacht. Auch hier sind alle \texttt{Singleton}-Objekte schon initialisiert. Bei der Erstellung des Parameter-Objekts durch \texttt{createParameters()} ist anzumerken, dass überprüft wird, ob bereits ein Parameter-Objekt vorliegt. Ist dies der Fall, wird kein neues Parameter-Objekt erstellt und andernfalls schon. \\

Durch das Klicken des Bearbeiters auf eine Kante und das anschließende Klicken auf den Button, welcher den Relationstyp auf ungewiss setzten soll, wird zuerst in \texttt{Values} der \texttt{EdgeArrowType} auf den entsprechenden Wert gesetzt. Anschließend wird eine \texttt{EditEdgesTypeLogAction} erstellt, und von der \texttt{ActionHistory} ausgeführt. Dann wird sich von \texttt{Syndrom} der \texttt{Graph} sowie der \texttt{VisualizationViewer} und sein \texttt{PickedState} geholt. Darauf folgt die Erstellung der Aktion. Erst bei der Ausführung wird das  zugehörige Parameter-Objekt erstellt. Danach folgt die Änderung der ausgewählten Kante, woraufhin die Benutzeroberfläche und der \texttt{SyndromGraph} aktualisiert werden. Aufgrund der Änderung des Graphen müssen der \texttt{DatabaseManager} und die \texttt{GUI} benachrichtigt werden. Einerseits wird der Graph neu als \texttt{GXL}-String in die Datenbank persistiert. Andererseits muss für die Protokollierung des Nutzerverhaltens eine neue \texttt{Log} erstellt und in die Datenbank persistiert werden. Dem \texttt{LogDao} werden hierfür die Log und die Parameter übergeben. Die Parameter werden zu einem JSON-String konvertiert und der entsprechende Log-Eintrag in der Datenbank gespeichert.  \\

Nun möchte der Bearbeiter seine letzte Aktion, also die Änderung des Relationstyps einer Kante, rückgängig machen, weshalb er den entsprechenden Button in der \texttt{GUI} betätigt. In der \texttt{ActionHistory} wird dann die \texttt{EditEdgesTypeLogAction} rückgängig gemacht, indem eine neue \texttt{EditEdgesTypeLogAction} mit den Attributen der alten \texttt{EditEdgesTypeLogAction}, jedoch vertauscht, erzeugt wird. Führt man diese Aktion nun aus, so wird aufgrund der vertauschten Attribute die rückgängig zu machende Aktion rückgängig gemacht. Bei der Ausführung dieser Aktion wird kein neues Parameter-Objekt erzeugt. Ansonsten wird wie oben beschrieben die Änderung der Kante, die Benachrichtigung von dem \texttt{DatabaseManager} und der \texttt{GUI}, die Aktualisierung des Graphen und die Speicherung des entsprechend neu erzeugten Log-Eintrages in der Datenbank ausgeführt. 

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{4. Sequenzdiagramm (Teil 1)},\pagestyle{fancy}}]{fourth.pdf}

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{4. Sequenzdiagramm (Teil 2)},\pagestyle{fancy}}]{fourth2.pdf}

\newpage

\subsection{Anwendungsfall: Ein Lehrer exportiert einen Graphen}

\begin{tabular} {|p{16cm}|}
	\hline
	\rowcolor{anw}\parbox{16cm}{\textbf{A5: Bearbeiter exportiert einen Graphen}} \\\hline
	\hline
	\textbf{Akteure}: Bearbeiter
	\\\hline
	\textbf{Vorbedingungen}: Das Programm ist geöffnet. Die GXL-Datei ist schon importiert. Es existiert eine Sphäre und ein Knoten in der Sphäre.\\ 
	\textit{Ziel}: Graphen exportieren.
	\\\hline
	\textbf{Regulärer Ablauf}:
\begin{itemize}
	\itemsep-0.5em
	\item der Bearbeiter klickt auf den Menüpunkt \textit{Datei} $\rightarrow$ \textit{exportieren als} $\rightarrow$ \textit{PDF}
	\item das System öffnet ein Pop-Up-Fenster
	\item der Bearbeiter gibt den Speicherpfad des Graphen an und klickt \textit{Ok}
\end{itemize}
	\\\hline
	\textbf{Varianten}: Zwischendurch kann der Bearbeiter den Graphen modifizieren und anschließend exportieren, sodass der Bearbeiter Exporte verschiedener Versionen hat.
	\\\hline
	\textbf{Nachbedingung}: Der Graph ist nun als PDF exportiert. Die PDF-Datei kann der Bearbeiter nun weitergeben, sodass jemand anderes den Graphen ausdrucken kann.
	\\\hline
	\textbf{Fehler-/Ausnahmefälle mit deren Nachbedingung}: Der Bearbeiter könnte einen falschen Pfad angeben $\rightarrow$ das System warnt den Bearbeiter und der Bearbeiter kann es erneut versuchen.
	\\\hline
\end{tabular}\\ \\ \\

Das folgende Sequenzdiagramm stellt den Fall dar, bei dem ein Benutzer den bestehenden Graphen als PDF exportiert. Klickt also der Benutzer auf den Button \textit{Exportieren als} $\rightarrow$ \textit{PDF}, reagiert darauf \texttt{GUI} mit einem Dialogfenster, bei dem der Nutzer einen validen Pfad eingeben und mit dem Button \textit{Exportieren} dies bestätigen muss. \\
Eine neue Action \texttt{exportPdfAction} wird erstellt und wieder durch die \texttt{ActionHistory} ausgeführt. Von Syndrom wird der \texttt{VisualisationViewer} geholt und an die Action übergeben. Mithilfe dieser Information wird ein neues Objekt von der Klasse \texttt{PDFIo} erstellt und initialisiert. Weiter im Verlauf der Action wird mithilfe der Methode \texttt{exportPDF()} ein neuer \texttt{ExportDialog} erstellt und darauf die Methode ausgeführt, die die PDF erstellt.\\ \\

\includepdf[pages=-, landscape, scale=0.84,pagecommand={\null\enlargethispage{2\baselineskip}\vfill\captionof{figure}{5. Sequenzdiagramm},\pagestyle{fancy}}]{fifth.pdf}


\newpage
\section{Evolution}
\label{sec:evolution}
\emph{Autoren: Bastian Rexhäuser, Anthony Mendil}\\\\
In diesem Kapitel wollen wir beschreiben wie sich ändernde Anforderungen auf unsere Architektur auswirken würden. Dabei gehen wir zunächst auf die Einflussfaktoren ein, deren Veränderlichkeit im Rahmen der globalen Analyse als eher hoch oder gar sehr hoch eingeschätzt wurde. Hierbei betrachten wir lediglich diejenigen, die Einfluss auf die Architektur haben. Allerdings haben wir keinen Einflussfaktor als sehr veränderlich eingestuft, sodass wir lediglich jene mit einer eher hohen Veränderlichkeit thematisieren werden. Bei den entsprechenden Einflussfaktoren werden wir beschreiben, welchen Einfluss eine potentielle Änderung des Einflussfaktors (beziehungsweise der Anforderung, die durch diesen Einflussfaktor repräsentiert wird) auf unsere Architektur hätte. Im Anschluss daran werden wir auf die Anforderungen aus dem Chinese Menue eingehen, deren Umsetzung in unserer Architektur aktuell nicht vorgesehen ist. Hier werden wir erklären wie die nachträgliche Umsetzung dieser Anforderungen unsere Architektur beeinflussen würde. \\ 
 
\subsection{Änderungen aktuell umgesetzter Anforderungen}
\subsubsection{Filterung von Knoten und Kanten}
Für die Filterung von Knoten und Kanten (\hyperlink{ss}{Filter von Knoten und Kanten}) könnten weitere Filteroptionen benötigt werden. Eine Erweiterung wäre zum Beispiel, dass der Benutzer als zusätzliche Filteroption die Knoten, Kanten und Sphären hervorheben kann, die in einem bestimmten Zeitraum hinzugefügt wurden. Hierfür könnte man in der GUI  ein Textfeld hinzufügen. Wird eine Zeitspanne (z.B 11:23-13:04) eingegeben, werden nur Elemente angezeigt, die in diesem Zeitraum hinzugefügt wurden. Es wäre jedoch auch möglich, mit relativen Zeiten zu arbeiten. Wird -00:10 eingegeben, werden nur Elemente angezeigt, die höchstens 10 Minuten vor dem letzten hinzugefügten Element hinzugefügt wurden und wird +00:10 eingegeben, werden die angezeigt, die höchstens 10 Minuten nach dem ersten hinzugefügten Element hinzugefügt wurden. Dies könnte man realisieren, indem die Einträge aus den Log-Einträgen herausgefiltert werden, die hinzufügende Aktionen beschreiben und deren Erstellungszeitpunkt sich im angegebenen Zeitraum befinden. Dann müssen die Identifikationsnummern der übrigen Graph-Elemente extrahiert und die dazugehörigen Graph-Elemente ausgeblendet werden. An dieser Stelle ist zu erwähnen, dass es auf diese Weise nicht möglich ist, Elemente die bereits in der Vorlage hinzugefügt wurden, zu filtern, da im Ersteller-Modus keine Log-Einträge erstellt werden. Hierfür müsste im Package \texttt{actions.analyse} die Klasse \texttt{FilterGraphAction} angepasst werden und im Package \texttt{graph.algorithmen.predicate} eine Klasse \texttt{ElementsCreatedInTimePredicate} hinzugefügt werden. \\

\subsubsection{Funktionsmodi}
Wie in der globalen Analyse zu sehen ist, weist der Einflussfaktor \hyperlink{z}{Funktionsmodi (Ersteller, Bearbeiter, Auswerter)} eine eher hohe Veränderlichkeit auf. Eine mögliche Änderung dieses Faktors wäre beispielsweise das Hinzukommen einer Rolle, mit der es möglich wäre, eine Vorlage auszuwerten oder einen erstellten Graphen zu kommentieren.
Die Auswertung einer Vorlage könnte in einer statistischen Auswertung des Anteils der Knoten, Sphären und Kanten in einer Vorlage bestehen, die später im \hyperlink{``Diagramm bearbeiten''-Modus}{\glqq Diagramm bearbeiten\grqq-Modus} vollständig beziehungsweise nur eingeschränkt (nur Farbe, nur Beschriftung) bearbeitet werden können. Im folgenden ist in diesem Fall vom Vorlage-Analyse-Modus die Rede.
Das Kommentieren eines erstellten Graphen ist wie folgt zu verstehen. Ein Graph kann geöffnet werden, wobei keine Eigenschaften mehr verändert werden können. Man kann allerdings die einzelnen Sphären, Knoten und Kanten anklicken (auch mehrere gleichzeitig, wenn sich das Kommentar auf mehrere Graph-Elemente bezieht) und einen Hinweis zu diesen schreiben. Diese Hinweise könnten dann nach dem Speichern / Exportieren des Graphen auch auf einem anderen Rechner gelesen werden. Voraussetzung ist die Aktivierung desselben Modus (wobei die Hinweise weiterhin verändert und auch wieder gelöscht werden könnten. Dieser Modus wird im Folgenden als Diagramm-Kommentieren-Modus bezeichnet.
Eine solche Änderung (das Hinzukommen von neuen Funktionsmodi mit neuen Funktionen) würde sich auf die im Package \texttt{graph.graph} befindliche Klasse \texttt{FunctionMode} sowie auf die Klasse \texttt{SwitchModiEditorAction} im Package \texttt{actions.io} auswirken. Über letztgenannte würde dann auch eine Änderung der Benutzeroberfläche ausgelöst werden. Die entsprechende Benutzeroberfläche würde Änderungen am \texttt{gui}-Package erforderlich machen, um eine den Anforderungen des neuen Funktionsmodus entsprechende Benutzeroberfläche bereitstellen zu können.
Für die Funktionalitäten des Vorlage-Analyse-Modus müsste außerdem eine Klasse (oder mehrere Klassen) im Package \texttt{actions.analyse} hinzugefügt werden, die eine entsprechende Filterung der Knoten, Kanten und Sphären vornehmen und durch Rechenoperationen den jeweiligen Anteil (entsprechend der Bearbeitungsmöglichkeiten) bestimmen würde.
Um die Funktionen des Diagramm-Kommentieren-Modus bereitzustellen, müsste unser System neben den oben erwähnten auch noch an folgenden Stellen angepasst werden: Die Klassen \texttt{Edge}, \texttt{Vertex} und \texttt{Sphere} im \texttt{graph.graph}-Package werden um ein Attribut zum Speichern des Kommentars erweitert. Dazu müsste man im \texttt{actions}-Package ein Package \texttt{comment} hinzufügen, in dem Methoden zum Hinzufügen, Editieren und Löschen von Kommentaren zu Sphären, Knoten und Kanten enthalten wären. \\
 
\subsection{Hinzukommen weiterer Anforderungen (Chinese Menue)}
\subsubsection{Wegpunkte}
Es ließen sich zusätzlich Wegpunkte (\texttt{O«Wegpunkte»}) mit dem Framework JGraph realisieren. Dazu müssten wir den Java-spezifischen Teil (JGraphX) dieses Frameworks in unser System integrieren. Da man Wegpunkte innerhalb dieses Frameworks auf Edge-Objekten hinzufügt, müssten wir in unserem System statt unserer \texttt{Edge}-Klasse diejenige von JGraphX verwenden. Da diese ihrerseits allerdings nicht alle von uns benötigten Informationen (in Form von Attributen) enthält, müssten wir weiterhin eine eigene \texttt{Edge}-Klasse in unserem System vorhalten. Diese müsste allerdings anders als bis jetzt die \texttt{Edge}-Klasse von JGraphX erweitern, um auch jene Anforderungen zu erfüllen, welche die \texttt{Edge}-Klasse aus dem aktuellem Projekt erfüllt. Diese alternative beziehungsweise neue \texttt{Edge}-Klasse würde dann überall dort verwendet, wo aktuell unsere jetzige \texttt{Edge}-Klasse angewandt wird. Zu diesen Änderungen müsste auch im \texttt{actions}-Package je eine Aktion zum Hinzufügen beziehungsweise Entfernen von Wegpunkten hinzugefügt werden. \\

\subsubsection{Kantenbündelung}
Des Weiteren wäre die Realisierung von Kantenbündelung (\texttt{O«Kantenbündelung»}) möglich, indem wir im Package \texttt{actions.visualization.renderers} die Klasse \texttt{EdgeRenderer} mithilfe eines selbst geschriebenen Algorithmus so anpassen, dass die Kanten entsprechend gerendert werden. Abgesehen davon hätte dies keine weiteren Auswirkungen auf die Architektur.  \\

\subsubsection{Mobil}
Um eine mobile Version (\texttt{O«Mobil»}) des Programms zu unterstützen müsste eine neue Applikation erstellt werden, wobei einige umfangreiche Anpassungen vorgenommen werden müssten. Dies beträfe in erster Linie die Benutzeroberfläche (Package: \texttt{gui}), da diese von Grund auf neu zu gestalten wäre, um auf mobilen Geräten nutzerfreundlich bedienbar zu sein. Hierbei unterstützen Android sowie IOS die Umsetzung der Benutzeroberfläche mittels JavaFX. Die Nutzung von der H2 Datenbank ist lediglich unter Android möglich. Für IOS bietet sich unter anderem eine sqlite-Datenbank an. Übrige Komponenten könnten größtenteils übernommen werden. 

\end{document}


%%% Local Variables:
%%% mode: latex
%%% mode: reftex
%%% mode: flyspell
%%% ispell-local-dictionary: "de_DE"
%%% TeX-master: t
%%% End:
